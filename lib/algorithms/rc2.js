/**
 * Javascript jCastle Mcrypt Module - RC2
 * 
 * @author Jacob Lee
 *
 * Copyright (C) 2015-2022 Jacob Lee.
 */
/* https://tools.ietf.org/html/rfc2268 */

var jCastle = require('../jCastle');
require('../util');

jCastle.algorithm.rc2 = class
{
	/**
	 * creates the algorithm instance.
	 * 
	 * @param {string} algo_name algorithm name
	 * @param {object} options object
	 * @constructor
	 */
    constructor(algo_name, options = {})
    {
        this.algoName = algo_name;
        this.masterKey = null;
        this.roundKey = null;
        this.rounds = 16;
        this.keyBits = 'effectiveKeyBits' in options ? options.effectiveKeyBits : null; // null value important!
    }

	/**
	 * validate the key size.
	 * 
	 * @public
	 * @param {buffer} key 
	 * @returns true if the key size is valid.
	 */
	isValidKeySize(key)
	{
		if (jCastle._algorithmInfo[this.algoName].min_key_size == jCastle._algorithmInfo[this.algoName].max_key_size) {
			if (key.length != jCastle._algorithmInfo[this.algoName].key_size) {
				return false;
			}
		} else {
			if (key.length > jCastle._algorithmInfo[this.algoName].max_key_size) {
				return false;
			}
			if (key.length < jCastle._algorithmInfo[this.algoName].min_key_size) {
				return false;
			}
			if (typeof jCastle._algorithmInfo[this.algoName].key_sizes != 'undefined' &&
            !jCastle._algorithmInfo[this.algoName].key_sizes.includes(key.length)
			) {
				return false;			
			}
		}
		return true;
	}

	/**
	 * resets internal variables except algoName.
	 * 
	 *  @public
	 */
	reset()
	{
		this.masterKey = null;
		this.roundKey = null;
		this.rounds = 16;
		this.keyBits = null;
		return this;
	}

	/**
	 * get the key.
	 * 
	 * @public
	 * @returns the masterKey.
	 */
    getKey()
    {
        return this.masterKey;
    }

	/**
	 * get the block size.
	 * 
	 * @public
	 * @returns the block size.
	 */
	getBlockSize()
	{
		return jCastle._algorithmInfo[this.algoName].block_size;
	}

	/**
	 * makes round key for encryption/decryption.
	 *
	 * @public
	 * @param {buffer} key encryption/decryption key.
	 * @param {boolean} isEncryption if encryption then true, otherwise false.
	 */
	keySchedule(key, isEncryption)
	{
		this.masterKey = Buffer.slice(key, 'latin1');

		this.expandKey(this.masterKey);
		return this;
	}

	/**
	 * encrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be encrypted.
	 * @returns encrypted block in buffer.
	 */
	encryptBlock(input)
	{
		var x = [];

		for (var i = 0; i < 4; i++) {
			x[i] = input.readUInt16LE(i * 2);
		}

		for (var i = 0; i < this.rounds; i++) {
			x[0] = (x[0] + (x[1] & ~x[3]) + (x[2] & x[3]) + this.roundKey[4 * i + 0]) & 0xFFFF;
			x[0] = ((x[0] << 1) | (x[0] >>> 15)) & 0xFFFF;

			x[1] = (x[1] + (x[2] & ~x[0]) + (x[3] & x[0]) + this.roundKey[4 * i + 1]) & 0xFFFF;
			x[1] = ((x[1] << 2) | (x[1] >>> 14)) & 0xFFFF;

			x[2] = (x[2] + (x[3] & ~x[1]) + (x[0] & x[1]) + this.roundKey[4 * i + 2]) & 0xFFFF;
			x[2] = ((x[2] << 3) | (x[2] >>> 13)) & 0xFFFF;

			x[3] = (x[3] + (x[0] & ~x[2]) + (x[1] & x[2]) + this.roundKey[4 * i + 3]) & 0xFFFF;
			x[3] = ((x[3] << 5) | (x[3] >>> 11)) & 0xFFFF;

			if (i == 4 || i == 10) {
				x[0] = (x[0] + this.roundKey[x[3] & 63]) & 0xFFFF;
				x[1] = (x[1] + this.roundKey[x[0] & 63]) & 0xFFFF;
				x[2] = (x[2] + this.roundKey[x[1] & 63]) & 0xFFFF;
				x[3] = (x[3] + this.roundKey[x[2] & 63]) & 0xFFFF;
			}
		}

		var output = Buffer.alloc(input.length);

		for (var i = 0; i < 4; i++) {
			output.writeUInt16LE(x[i] & 0xffff, i * 2);
		}

		return output;
	}

	/**
	 * decrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be decrypted.
	 * @returns the decrypted block in buffer.
	 */
	decryptBlock(input)
	{
		var x = [];

		for (var i = 0; i < 4; i++) {
			x[i] = input.readUInt16LE(i * 2);
		}

		for (var i = (this.rounds-1); i >= 0; i--) {
			if (i == 4 || i == 10) {
				x[3] = (x[3] - this.roundKey[x[2] & 63]) & 0xFFFF;
				x[2] = (x[2] - this.roundKey[x[1] & 63]) & 0xFFFF;
				x[1] = (x[1] - this.roundKey[x[0] & 63]) & 0xFFFF;
				x[0] = (x[0] - this.roundKey[x[3] & 63]) & 0xFFFF;
			}

			x[3] = ((x[3] << 11) | (x[3] >>> 5)) & 0xFFFF;
			x[3] = (x[3] - ((x[0] & ~x[2]) + (x[1] & x[2]) + this.roundKey[4 * i + 3])) & 0xFFFF;

			x[2] = ((x[2] << 13) | (x[2] >>> 3)) & 0xFFFF;
			x[2] = (x[2] - ((x[3] & ~x[1]) + (x[0] & x[1]) + this.roundKey[4 * i + 2])) & 0xFFFF;

			x[1] = ((x[1] << 14) | (x[1] >>> 2)) & 0xFFFF;
			x[1] = (x[1] - ((x[2] & ~x[0]) + (x[3] & x[0]) + this.roundKey[4 * i + 1])) & 0xFFFF;

			x[0] = ((x[0] << 15) | (x[0] >>> 1)) & 0xFFFF;
			x[0] = (x[0] - ((x[1] & ~x[3]) + (x[2] & x[3]) + this.roundKey[4 * i + 0])) & 0xFFFF;
		}

		var output = Buffer.alloc(input.length);

		for (var i = 0; i < 4; i++) {
			output.writeUInt16LE(x[i] & 0xffff, i * 2);
		}

		return output;
	}

	/**
	 * Calculate the necessary round keys.
	 * The number of calculations depends on key size and block size.
	 * 
	 * @private
	 * @param {buffer} key key for encryption/decryption.
	 * @param {boolean} isEncryption true if it is encryption, otherwise false.
	 */
	expandKey(key)
	{
		//var tmp = []; // 128
		//var tmp = new Array(128).fill(0);
		var tmp = new Uint8Array(128).fill(0);
		var T8, TM;
		var i, bits;
		var keylen = key.length;
		this.roundKey = new Array(64).fill(0);

		//if (keylen < 5 || keylen > 128) {
		if (keylen < 1 || keylen > 128) {
			throw jCastle.exception("INVALID_KEYSIZE", 'RC2001');
		}
		
		for (i = 0; i < keylen; i++) {
			tmp[i] = key[i] & 255;
		}

		// Phase 1: Expand input key to 128 bytes
		if (keylen < 128) {
			for (var j = keylen; j < 128; j++) {
				tmp[j] = jCastle.algorithm.rc2.pitable[(tmp[j - keylen] + tmp[j - 1]) & 0xff];
			}
			tmp[0] = jCastle.algorithm.rc2.pitable[tmp[0]];
		}
		
		// Phase 2 - reduce effective key size to "bits"
		if (this.keyBits) bits = this.keyBits;
		else bits = keylen << 3;

		T8   = ((bits + 7) >>> 3) & 0xFF;
		TM   = (255 >>> (7 & -bits)) & 0xFF;
		tmp[128 - T8] = jCastle.algorithm.rc2.pitable[tmp[128 - T8] & TM];
		for (i = 127 - T8; i >= 0; i--) {
			tmp[i] = jCastle.algorithm.rc2.pitable[tmp[i + 1] ^ tmp[i + T8]];
		}

		// Phase 3 - copy to xkey in little-endian order
		i = 63;
		do {
			this.roundKey[i] = (tmp[2 * i] + (tmp[2 * i + 1] << 8)) & 0xFFFF;
		} while (i--);
	}
};

/*
https://tools.ietf.org/html/rfc2268

6. RC2 Algorithm Object Identifier

   The Object Identifier for RC2 in cipher block chaining mode is

   rc2CBC OBJECT IDENTIFIER
     ::= {iso(1) member-body(2) US(840) rsadsi(113549)
          encryptionAlgorithm(3) 2}

   RC2-CBC takes parameters

   RC2-CBCParameter ::= CHOICE {
     iv IV,
     params SEQUENCE {
       version RC2Version,
       iv IV
     }
   }

   where

   IV ::= OCTET STRING -- 8 octets
   RC2Version ::= INTEGER -- 1-1024

   RC2 in CBC mode has two parameters: an 8-byte initialization vector
   (IV) and a version number in the range 1-1024 which specifies in a
   roundabout manner the number of effective key bits to be used for the
   RC2 encryption/decryption.

   The correspondence between effective key bits and version number is
   as follows:

   1. If the number EKB of effective key bits is in the range 1-255,
      then the version number is given by Table[EKB], where the 256-byte
      translation table Table[] is specified below. Table[] specifies a
      permutation on the numbers 0-255; note that it is not the same
      table that appears in the key expansion phase of RC2.

   2. If the number EKB of effective key bits is in the range
      256-1024, then the version number is simply EKB.

      The default number of effective key bits for RC2 is 32. If RC2-CBC
      is being performed with 32 effective key bits, the parameters
      should be supplied as a simple IV, rather than as a SEQUENCE
      containing a version and an IV.

        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f

   00: bd 56 ea f2 a2 f1 ac 2a b0 93 d1 9c 1b 33 fd d0
   10: 30 04 b6 dc 7d df 32 4b f7 cb 45 9b 31 bb 21 5a
   20: 41 9f e1 d9 4a 4d 9e da a0 68 2c c3 27 5f 80 36
   30: 3e ee fb 95 1a fe ce a8 34 a9 13 f0 a6 3f d8 0c
   40: 78 24 af 23 52 c1 67 17 f5 66 90 e7 e8 07 b8 60
   50: 48 e6 1e 53 f3 92 a4 72 8c 08 15 6e 86 00 84 fa
   60: f4 7f 8a 42 19 f6 db cd 14 8d 50 12 ba 3c 06 4e
   70: ec b3 35 11 a1 88 8e 2b 94 99 b7 71 74 d3 e4 bf
   80: 3a de 96 0e bc 0a ed 77 fc 37 6b 03 79 89 62 c6
   90: d7 c0 d2 7c 6a 8b 22 a3 5b 05 5d 02 75 d5 61 e3
   a0: 18 8f 55 51 ad 1f 0b 5e 85 e5 c2 57 63 ca 3d 6c
   b0: b4 c5 cc 70 b2 91 59 0d 47 20 c8 4f 58 e0 01 e2
   c0: 16 38 c4 6f 3b 0f 65 46 be 7e 2d 7b 82 f9 40 b5
   d0: 1d 73 f8 eb 26 c7 87 97 25 54 b1 28 aa 98 9d a5
   e0: 64 6d 7a d4 10 81 44 ef 49 d6 ae 2e dd 76 5c 2f
   f0: a7 1c c9 09 69 9a 83 cf 29 39 b9 e9 4c ff 43 ab

*/
jCastle.algorithm.rc2.getVersion = function(ekb)
{
	if (ekb > 255) return ekb;
	return jCastle.algorithm.rc2.version_table[ekb];
};

jCastle.algorithm.rc2.getEffectiveKeyBits = function(version)
{
	if (version > 255) return version;
	return jCastle.algorithm.rc2.ekb_table[version];
};



/*
 * ---------
 * Constants
 * ---------
 */

// 256-entry permutation table, probably derived somehow from pi 
jCastle.algorithm.rc2.pitable = [
	0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d, 
	0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2, 
	0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32, 
	0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82, 
	0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc, 
	0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26, 
	0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03, 
	0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7, 
	0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a, 
	0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec, 
	0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39, 
	0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31, 
	0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9, 
	0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9, 
	0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e, 
	0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad 
];


jCastle.algorithm.rc2.version_table = [
	0xbd, 0x56, 0xea, 0xf2, 0xa2, 0xf1, 0xac, 0x2a, 0xb0, 0x93, 0xd1, 0x9c, 0x1b, 0x33, 0xfd, 0xd0,
	0x30, 0x04, 0xb6, 0xdc, 0x7d, 0xdf, 0x32, 0x4b, 0xf7, 0xcb, 0x45, 0x9b, 0x31, 0xbb, 0x21, 0x5a,
	0x41, 0x9f, 0xe1, 0xd9, 0x4a, 0x4d, 0x9e, 0xda, 0xa0, 0x68, 0x2c, 0xc3, 0x27, 0x5f, 0x80, 0x36,
	0x3e, 0xee, 0xfb, 0x95, 0x1a, 0xfe, 0xce, 0xa8, 0x34, 0xa9, 0x13, 0xf0, 0xa6, 0x3f, 0xd8, 0x0c,
	0x78, 0x24, 0xaf, 0x23, 0x52, 0xc1, 0x67, 0x17, 0xf5, 0x66, 0x90, 0xe7, 0xe8, 0x07, 0xb8, 0x60,
	0x48, 0xe6, 0x1e, 0x53, 0xf3, 0x92, 0xa4, 0x72, 0x8c, 0x08, 0x15, 0x6e, 0x86, 0x00, 0x84, 0xfa,
	0xf4, 0x7f, 0x8a, 0x42, 0x19, 0xf6, 0xdb, 0xcd, 0x14, 0x8d, 0x50, 0x12, 0xba, 0x3c, 0x06, 0x4e,
	0xec, 0xb3, 0x35, 0x11, 0xa1, 0x88, 0x8e, 0x2b, 0x94, 0x99, 0xb7, 0x71, 0x74, 0xd3, 0xe4, 0xbf,
	0x3a, 0xde, 0x96, 0x0e, 0xbc, 0x0a, 0xed, 0x77, 0xfc, 0x37, 0x6b, 0x03, 0x79, 0x89, 0x62, 0xc6,
	0xd7, 0xc0, 0xd2, 0x7c, 0x6a, 0x8b, 0x22, 0xa3, 0x5b, 0x05, 0x5d, 0x02, 0x75, 0xd5, 0x61, 0xe3,
	0x18, 0x8f, 0x55, 0x51, 0xad, 0x1f, 0x0b, 0x5e, 0x85, 0xe5, 0xc2, 0x57, 0x63, 0xca, 0x3d, 0x6c,
	0xb4, 0xc5, 0xcc, 0x70, 0xb2, 0x91, 0x59, 0x0d, 0x47, 0x20, 0xc8, 0x4f, 0x58, 0xe0, 0x01, 0xe2,
	0x16, 0x38, 0xc4, 0x6f, 0x3b, 0x0f, 0x65, 0x46, 0xbe, 0x7e, 0x2d, 0x7b, 0x82, 0xf9, 0x40, 0xb5,
	0x1d, 0x73, 0xf8, 0xeb, 0x26, 0xc7, 0x87, 0x97, 0x25, 0x54, 0xb1, 0x28, 0xaa, 0x98, 0x9d, 0xa5,
	0x64, 0x6d, 0x7a, 0xd4, 0x10, 0x81, 0x44, 0xef, 0x49, 0xd6, 0xae, 0x2e, 0xdd, 0x76, 0x5c, 0x2f,
	0xa7, 0x1c, 0xc9, 0x09, 0x69, 0x9a, 0x83, 0xcf, 0x29, 0x39, 0xb9, 0xe9, 0x4c, 0xff, 0x43, 0xab
];

jCastle.algorithm.rc2.ekb_table = [
	0x5d, 0xbe, 0x9b, 0x8b, 0x11, 0x99, 0x6e, 0x4d, 0x59, 0xf3, 0x85, 0xa6, 0x3f, 0xb7, 0x83, 0xc5,
	0xe4, 0x73, 0x6b, 0x3a, 0x68, 0x5a, 0xc0, 0x47, 0xa0, 0x64, 0x34, 0x0c, 0xf1, 0xd0, 0x52, 0xa5,
	0xb9, 0x1e, 0x96, 0x43, 0x41, 0xd8, 0xd4, 0x2c, 0xdb, 0xf8, 0x07, 0x77, 0x2a, 0xca, 0xeb, 0xef,
	0x10, 0x1c, 0x16, 0x0d, 0x38, 0x72, 0x2f, 0x89, 0xc1, 0xf9, 0x80, 0xc4, 0x6d, 0xae, 0x30, 0x3d,
	0xce, 0x20, 0x63, 0xfe, 0xe6, 0x1a, 0xc7, 0xb8, 0x50, 0xe8, 0x24, 0x17, 0xfc, 0x25, 0x6f, 0xbb,
	0x6a, 0xa3, 0x44, 0x53, 0xd9, 0xa2, 0x01, 0xab, 0xbc, 0xb6, 0x1f, 0x98, 0xee, 0x9a, 0xa7, 0x2d,
	0x4f, 0x9e, 0x8e, 0xac, 0xe0, 0xc6, 0x49, 0x46, 0x29, 0xf4, 0x94, 0x8a, 0xaf, 0xe1, 0x5b, 0xc3,
	0xb3, 0x7b, 0x57, 0xd1, 0x7c, 0x9c, 0xed, 0x87, 0x40, 0x8c, 0xe2, 0xcb, 0x93, 0x14, 0xc9, 0x61,
	0x2e, 0xe5, 0xcc, 0xf6, 0x5e, 0xa8, 0x5c, 0xd6, 0x75, 0x8d, 0x62, 0x95, 0x58, 0x69, 0x76, 0xa1,
	0x4a, 0xb5, 0x55, 0x09, 0x78, 0x33, 0x82, 0xd7, 0xdd, 0x79, 0xf5, 0x1b, 0x0b, 0xde, 0x26, 0x21,
	0x28, 0x74, 0x04, 0x97, 0x56, 0xdf, 0x3c, 0xf0, 0x37, 0x39, 0xdc, 0xff, 0x06, 0xa4, 0xea, 0x42,
	0x08, 0xda, 0xb4, 0x71, 0xb0, 0xcf, 0x12, 0x7a, 0x4e, 0xfa, 0x6c, 0x1d, 0x84, 0x00, 0xc8, 0x7f,
	0x91, 0x45, 0xaa, 0x2b, 0xc2, 0xb1, 0x8f, 0xd5, 0xba, 0xf2, 0xad, 0x19, 0xb2, 0x67, 0x36, 0xf7,
	0x0f, 0x0a, 0x92, 0x7d, 0xe3, 0x9d, 0xe9, 0x90, 0x3e, 0x23, 0x27, 0x66, 0x13, 0xec, 0x81, 0x15,
	0xbd, 0x22, 0xbf, 0x9f, 0x7e, 0xa9, 0x51, 0x4b, 0x4c, 0xfb, 0x02, 0xd3, 0x70, 0x86, 0x31, 0xe7,
	0x3b, 0x05, 0x03, 0x54, 0x60, 0x48, 0x65, 0x18, 0xd2, 0xcd, 0x5f, 0x32, 0x88, 0x0e, 0x35, 0xfd
];


jCastle._algorithmInfo['rc2'] = {
	algorithm_type: 'crypt',
	block_size: 8,
	key_size: 16, // 32
	min_key_size: 5,
	max_key_size: 128,
	padding: 'zeros',
	object_name: 'rc2'
};

jCastle._algorithmInfo['rc2-40'] = {
	algorithm_type: 'crypt',
	block_size: 8,
	key_size: 5,
	min_key_size: 5,
	max_key_size: 128,
	padding: 'zeros',
	object_name: 'rc2'
};

jCastle._algorithmInfo['rc2-64'] = {
	algorithm_type: 'crypt',
	block_size: 8,
	key_size: 8,
	min_key_size: 5,
	max_key_size: 128,
	padding: 'zeros',
	object_name: 'rc2'
};

jCastle._algorithmInfo['rc2-128'] = {
	algorithm_type: 'crypt',
	block_size: 8,
	key_size: 16,
	min_key_size: 5,
	max_key_size: 128,
	padding: 'zeros',
	object_name: 'rc2'
};

module.exports = jCastle.algorithm.rc2;