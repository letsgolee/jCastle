/**
 * Javascript jCastle Mcrypt Module - Rijndael 
 * 
 * @author Jacob Lee
 *
 * Copyright (C) 2015-2022 Jacob Lee.
 */

var jCastle = require('../jCastle');
require('../util');

jCastle.algorithm.rijndael = class
{
	/**
	 * creates the algorithm instance.
	 * 
	 * @param {string} algo_name algorithm name
	 * @constructor
	 */
    constructor(algo_name)
    {
        this.algoName = algo_name;
        this.masterKey = null;
        this.roundKey = null;
    }

	/**
	 * validate the key size.
	 * 
	 * @public
	 * @param {buffer} key 
	 * @returns true if the key size is valid.
	 */
	isValidKeySize(key)
	{
		if (jCastle._algorithmInfo[this.algoName].min_key_size == jCastle._algorithmInfo[this.algoName].max_key_size) {
			if (key.length != jCastle._algorithmInfo[this.algoName].key_size) {
				return false;
			}
		} else {
			if (key.length > jCastle._algorithmInfo[this.algoName].max_key_size) {
				return false;
			}
			if (key.length < jCastle._algorithmInfo[this.algoName].min_key_size) {
				return false;
			}
			if (typeof jCastle._algorithmInfo[this.algoName].key_sizes != 'undefined' &&
            !jCastle._algorithmInfo[this.algoName].key_sizes.includes(key.length)
			) {
				return false;			
			}
		}
		return true;
	}

	/**
	 * resets internal variables except algoName.
	 * 
	 *  @public
	 */
	reset()
	{
		this.masterKey = null;
		this.roundKey = null;
		return this;
	}

	/**
	 * get the key.
	 * 
	 * @public
	 * @returns the masterKey.
	 */
    getKey()
	{
		return this.masterKey;
	}

	/**
	 * get the block size.
	 * 
	 * @public
	 * @returns the block size.
	 */
	getBlockSize()
	{
		return jCastle._algorithmInfo[this.algoName].block_size;
	}

	/**
	 * makes round key for encryption/decryption.
	 *
	 * @public
	 * @param {buffer} key encryption/decryption key.
	 * @param {boolean} isEncryption if encryption then true, otherwise false.
	 */
	keySchedule(key, direction)
	{
		// for bug issue see 
		// http://stackoverflow.com/questions/18786025/mcrypt-js-encryption-value-is-different-than-that-produced-by-php-mcrypt-mcryp
		this.masterKey = Buffer.from(key, 'latin1');
		
		var enckey = Buffer.slice(this.masterKey);
		
//		while (key.length != 16 && key.length != 24 && key.length != 32) {
//			key.push(0x00);
//		}

		var keylen = enckey.length;

		var a = 0;
		while (keylen != 16 && keylen != 24 && keylen != 32) {
			a++;
			keylen++;
		}

		if (a) enckey = Buffer.concat([enckey, Buffer.alloc(a)]);


		this.keySize = enckey.length;

	/*
		switch (key.length) {
			case 16: this.rounds = 10; break;
			case 24: this.rounds = 12; break;
			case 32: this.rounds = 14; break;
		}
	*/
		// no of rounds: 10/12/14 for 128/192/256-bit keys
		this.rounds = (this.keySize / 4) + 6;

		this.expandKey(enckey);

		return this;
	}

	/**
	 * encrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be encrypted.
	 * @returns encrypted block in buffer.
	 */
	encryptBlock(input)
	{
		var block_size = input.length;
		var output = Buffer.slice(input);
		var rounds = this.rounds;

		if (block_size % 8) {
			throw jCastle.exception("INVALID_INPUT_SIZE");
		}

		if (block_size > this.keySize) {
			rounds += (block_size - this.keySize) / 4;
		}

		var shiftRow = jCastle.algorithm.rijndael.shiftrow[block_size * 8];
			
		this.addRoundKey(output, this.roundKey.slice(0, block_size));
		for(var r = 1; r < rounds; r++) {
			this.subBytes(output, true);
			this.shiftRows(output, shiftRow);
			this.mixColumns(output);
			this.addRoundKey(output, this.roundKey.slice(r * block_size, r * block_size + block_size));
		}
		this.subBytes(output, true);
		this.shiftRows(output, shiftRow);
		this.addRoundKey(output, this.roundKey.slice(rounds * block_size, rounds * block_size + block_size));

		return output;
	}

	/**
	 * decrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be decrypted.
	 * @returns the decrypted block in buffer.
	 */
	decryptBlock(input)
	{
		var block_size = input.length;
		var output = Buffer.slice(input);
		var rounds = this.rounds;

		if (block_size % 8) {
			throw jCastle.exception("INVALID_INPUT_SIZE");
		}

		if (block_size > this.keySize) {
			rounds += (block_size - this.keySize) / 4;
		}

		var shiftRow = jCastle.algorithm.rijndael.shiftrow_inverse[block_size * 8];
			
		this.addRoundKey(output, this.roundKey.slice(rounds * block_size, rounds * block_size + block_size));
		this.shiftRows(output, shiftRow);
		this.subBytes(output, false);
		for(var r = rounds - 1; r >= 1; r--) {
			this.addRoundKey(output, this.roundKey.slice(r * block_size, r * block_size + block_size));
			this.inverseMixColumns(output);
			this.shiftRows(output, shiftRow);
			this.subBytes(output, false);
		}
		this.addRoundKey(output, this.roundKey.slice(0, block_size));

		return output;
	}

	/**
	 * Calculate the necessary round keys.
	 * The number of calculations depends on key size and block size.
	 * 
	 * @private
	 * @param {buffer} key key for encryption/decryption.
	 * @param {boolean} isEncryption true if it is encryption, otherwise false.
	 */
	expandKey(key, isEncryption)
	{
		var key_len = key.length;
		// this version accepts various input size: 16/24/32.
		// we do not know the input block size, so the key should be expanded at maximum.
	//	var key_shft = 15 << 5;
		var max_rounds = 14;
		var max_input_block_size = 32;
		var key_shft = (max_rounds + 1) * max_input_block_size;
		var Rcon = 1;

		this.roundKey = new Array(key_shft);

		for(var i = 0; i < key_len; i++) {
			this.roundKey[i] = key[i];
		}

		for(var i = key_len; i < key_shft; i += 4) {
			var word = this.roundKey.slice(i - 4, i);

			if (i % key_len == 0) {
				this.rotWord(word);
				this.subWord(word);
				word[0] ^= Rcon;

				Rcon <<= 1;
				if (Rcon >= 256) {
					Rcon ^= 0x11b;
				}
			} else if ((key_len > 24) && (i % key_len == 16)) {
				this.subWord(word);
			}

			for(var j = 0; j < 4; j++) {
				this.roundKey[i + j] = this.roundKey[i + j - key_len] ^ word[j];
			}
		}
	}

	subWord(word)
	{
		// apply SBOX to 4-byte word
		for (var i = 0; i < 4; i++) {
			word[i] = jCastle.algorithm.rijndael.sbox[word[i]];
		}
	}

	rotWord(word)
	{
		// rotate 4-byte word left by one byte
		var tmp = word[0];
		for (var i = 0; i < 4; i++) {
			word[i] = (i==3) ? tmp : word[i + 1];
		}
	}

	subBytes(state, direction)
	{
		var sbox = direction ? jCastle.algorithm.rijndael.sbox : jCastle.algorithm.rijndael.sbox_inverse;
		
		for(var i = state.length - 1; i >= 0; i--) {
			state[i] = sbox[state[i]];  
		}
	}

	addRoundKey (state, rkey)
	{
		for(var i = state.length - 1; i >= 0 ; i--) {
			state[i] ^= rkey[i];
		}
	}

	shiftRows(state, shiftrow)
	{
		var h = Buffer.slice(state);
		for(var i = state.length - 1; i >= 0; i--) {
			state[i] = h[shiftrow[i]];
		}
	}

	mixColumns(state)
	{
		var xtime = jCastle.algorithm.rijndael.xtime;
		
		for (var i = 0; i < state.length; i += 4) {
			var s0 = state[i + 0], s1 = state[i + 1], s2 = state[i + 2], s3 = state[i + 3];
			var h = s0 ^ s1 ^ s2 ^ s3;
			
			state[i + 0] ^= h ^ xtime[s0 ^ s1];
			state[i + 1] ^= h ^ xtime[s1 ^ s2];
			state[i + 2] ^= h ^ xtime[s2 ^ s3];
			state[i + 3] ^= h ^ xtime[s3 ^ s0];
		}
	}

	inverseMixColumns(state)
	{
		var xtime = jCastle.algorithm.rijndael.xtime;
		
		for (var i = 0; i < state.length; i += 4) {
			var s0 = state[i + 0], s1 = state[i + 1], s2 = state[i + 2], s3 = state[i + 3];
			var h = s0 ^ s1 ^ s2 ^ s3;
			var xh = xtime[h];
			var h1 = xtime[xtime[xh ^ s0 ^ s2]] ^ h;
			var h2 = xtime[xtime[xh ^ s1 ^ s3]] ^ h;
			
			state[i + 0] ^= h1 ^ xtime[s0 ^ s1];
			state[i + 1] ^= h2 ^ xtime[s1 ^ s2];
			state[i + 2] ^= h1 ^ xtime[s2 ^ s3];
			state[i + 3] ^= h2 ^ xtime[s3 ^ s0];
		}
	}
}



/*
 * ---------
 * Constants
 * ---------
 */

Object.assign(jCastle.algorithm.rijndael,
{
	sbox: [
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01,
		0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d,
		0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4,
		0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7,
		0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
		0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e,
		0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb,
		0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb,
		0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,
		0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c,
		0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d,
		0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a,
		0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3,
		0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
		0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a,
		0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e,
		0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,
		0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9,
		0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99,
		0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	],

	sbox_inverse: [
		0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 
		0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 
		0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 
		0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 
		0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 
		0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 
		0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 
		0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 
		0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 
		0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 
		0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 
		0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 
		0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 
		0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 
		0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 
		0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 
		0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 
		0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 
		0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 
		0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 
		0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 
		0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 
		0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	],

	shiftrow: {
		128: [
			0x00, 0x05, 0x0a, 0x0f, 0x04, 0x09, 0x0e, 0x03, 0x08, 0x0d, 
			0x02, 0x07, 0x0c, 0x01, 0x06, 0x0b, 0x00],
		192: [
			0x00, 0x05, 0x0a, 0x0f, 0x04, 0x09, 0x0e, 0x13, 0x08, 0x0d, 
			0x12, 0x17, 0x0c, 0x11, 0x16, 0x03, 0x10, 0x15, 0x02, 0x07, 
			0x14, 0x01, 0x06, 0x0b, 0x00,],
		256: [
			0x00, 0x05, 0x0e, 0x13, 0x04, 0x09, 0x12, 0x17, 0x08, 0x0d, 
			0x16, 0x1b, 0x0c, 0x11, 0x1a, 0x1f, 0x10, 0x15, 0x1e, 0x03, 
			0x14, 0x19, 0x02, 0x07, 0x18, 0x1d, 0x06, 0x0b, 0x1c, 0x01, 
			0x0a, 0x0f, 0x00]
	},

	shiftrow_inverse: {
		128: [
			0x00, 0x0d, 0x0a, 0x07, 0x04, 0x01, 0x0e, 0x0b, 0x08, 0x05, 
			0x02, 0x0f, 0x0c, 0x09, 0x06, 0x03],
		192: [
			0x00, 0x15, 0x12, 0x0f, 0x04, 0x01, 0x16, 0x13, 0x08, 0x05, 
			0x02, 0x17, 0x0c, 0x09, 0x06, 0x03, 0x10, 0x0d, 0x0a, 0x07, 
			0x14, 0x11, 0x0e, 0x0b],
		256: [
			0x00, 0x1d, 0x16, 0x13, 0x04, 0x01, 0x1a, 0x17, 0x08, 0x05, 
			0x1e, 0x1b, 0x0c, 0x09, 0x02, 0x1f, 0x10, 0x0d, 0x06, 0x03, 
			0x14, 0x11, 0x0a, 0x07, 0x18, 0x15, 0x0e, 0x0b, 0x1c, 0x19, 
			0x12, 0x0f]
	},

	xtime: [
		0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 
		0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 
		0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 
		0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 
		0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 
		0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 
		0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 
		0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 
		0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 
		0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 
		0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 
		0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 
		0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 
		0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 
		0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 
		0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 
		0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 
		0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 
		0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 
		0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 
		0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 
		0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 
		0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 
		0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 
		0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 
		0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
	]

// you can use this function, but a predefined array is more faster.
//	xtime: function(x) {
//		return x < 0x80 ? x << 1 : ((x - 0x80) << 1) ^ 0x1b;
//	}
});

//jCastle.algorithm.rijndael.sbox_inverse = new Array(256);
//for(var i = 0; i < 256; i++) {
//	jCastle.algorithm.rijndael.sbox_inverse[jCastle.algorithm.rijndael.sbox[i]] = i;
//}

/*
jCastle.algorithm.rijndael.sizes = [16, 24, 32];

jCastle.algorithm.rijndael.rowShifts=[
//   0	1	2	3		block Bytes
	[0,	1,	2,	3],		//16
	[0,	1,	2,	3],		//24
	[0,	1,	3,	4]		//32
];

jCastle.algorithm.rijndael.shiftrow = new Array(3);
for(var i = 0; i < 3; i++) {
	jCastle.algorithm.rijndael.shiftrow[i] = new Array(jCastle.algorithm.rijndael.sizes[i]);
	for(var j = jCastle.algorithm.rijndael.sizes[i]; j >= 0; j--) {
		jCastle.algorithm.rijndael.shiftrow[i][j] = (j + (jCastle.algorithm.rijndael.rowShifts[i][j&3] << 2)) % jCastle.algorithm.rijndael.sizes[i];
	}
}
*/

//jCastle.algorithm.rijndael.shiftrow_inverse = Array(3);
//for(var i = 0; i < 3; i++) {
//	jCastle.algorithm.rijndael.shiftrow_inverse[i] = new Array(jCastle.algorithm.rijndael.sizes[i]);
//	for(var j = jCastle.algorithm.rijndael.sizes[i]; j >= 0; j--) {
//		jCastle.algorithm.rijndael.shiftrow_inverse[i][jCastle.algorithm.rijndael.shiftrow[i][j]] = j;
//	}
//}

//jCastle.algorithm.rijndael.xtime = new Array(256);
//for(var i = 0; i < 128; i++) {
//	jCastle.algorithm.rijndael.xtime[i] = i << 1;
//	jCastle.algorithm.rijndael.xtime[128 + i] = (i << 1) ^ 0x1b;
//}


jCastle._algorithmInfo['rijndael'] = {
	algorithm_type: 'crypt',
	block_size: 16,
	block_sizes: [16, 24, 32],
	key_size: 32,
	min_key_size: 16,
	max_key_size: 32,
	key_sizes: [16, 24, 32],
	padding: 'zeros',
	object_name: 'rijndael'
};

jCastle._algorithmInfo['rijndael-128'] = {
	algorithm_type: 'crypt',
	block_size: 16,
	block_sizes: [16, 24, 32],
	key_size: 16,
	min_key_size: 16,
	max_key_size: 32,
	key_sizes: [16, 24, 32],
	padding: 'zeros',
	object_name: 'rijndael'
};

jCastle._algorithmInfo['rijndael-192'] = {
	algorithm_type: 'crypt',
	block_size: 24,
	block_sizes: [16, 24, 32],
	key_size: 24,
	min_key_size: 24,
	max_key_size: 32,
	key_sizes: [24, 32],
	padding: 'zeros',
	object_name: 'rijndael'
};

jCastle._algorithmInfo['rijndael-256'] = {
	algorithm_type: 'crypt',
	block_size: 32,
	block_sizes: [16, 24, 32],
	key_size: 32,
	min_key_size: 32,
	max_key_size: 32,
	padding: 'zeros',
	object_name: 'rijndael'
};

module.exports = jCastle.algorithm.rijndael;