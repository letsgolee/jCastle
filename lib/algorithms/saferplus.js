/**
 * Javascript jCastle Mcrypt Module - SaferPlus
 * 
 * @author Jacob Lee
 *
 * Copyright (C) 2015-2021 Jacob Lee.
 */

var jCastle = require('../jCastle');
require('../util');

jCastle.algorithm.saferplus = class
{
	/**
	 * creates the algorithm instance.
	 * 
	 * @param {string} algo_name algorithm name
	 * @constructor
	 */
    constructor(algo_name)
    {
        this.algoName = algo_name;
        this.masterKey = null;
        this.roundKeys = null; // [33][16]
        this.rounds = 0;
    }

    /**
	 * validate the key size.
	 * 
	 * @public
	 * @param {buffer} key 
	 * @returns true if the key size is valid.
	 */
	isValidKeySize(key)
	{
		if (jCastle._algorithmInfo[this.algoName].min_key_size == jCastle._algorithmInfo[this.algoName].max_key_size) {
			if (key.length != jCastle._algorithmInfo[this.algoName].key_size) {
				return false;
			}
		} else {
			if (key.length > jCastle._algorithmInfo[this.algoName].max_key_size) {
				return false;
			}
			if (key.length < jCastle._algorithmInfo[this.algoName].min_key_size) {
				return false;
			}
			if (typeof jCastle._algorithmInfo[this.algoName].key_sizes != 'undefined' &&
            !jCastle._algorithmInfo[this.algoName].key_sizes.includes(key.length)
			) {
				return false;			
			}
		}
		return true;
	}

	/**
	 * resets internal variables except algoName.
	 * 
	 *  @public
	 */
	reset()
	{
		this.masterKey = null;
		this.roundKeys = null;
		this.rounds = 8;
		return this;
	}

	/**
	 * get the key.
	 * 
	 * @public
	 * @returns the masterKey.
	 */
    getKey()
    {
        return this.masterKey;
    }

	/**
	 * get the block size.
	 * 
	 * @public
	 * @returns the block size.
	 */
	getBlockSize()
	{
		return jCastle._algorithmInfo[this.algoName].block_size;
	}

	/**
	 * makes round key for encryption/decryption.
	 *
	 * @public
	 * @param {buffer} key encryption/decryption key.
	 * @param {boolean} isEncryption if encryption then true, otherwise false.
	 */
	keySchedule(key, isEncryption)
	{
		this.masterKey = Buffer.from(key, 'latin1');
		
		this.expandKey(this.masterKey);
		return this;
	}

	/**
	 * encrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be encrypted.
	 * @returns encrypted block in buffer.
	 */
	encryptBlock(input)
	{
		var block = Buffer.alloc(input.length);
		var x;
		var b = this.swapWords(input);

		/* do eight rounds */
		this.ROUND(b,  0);  this.LT(b, block);
		this.ROUND(block, 2);  this.LT(block, b);
		this.ROUND(b,  4);  this.LT(b, block);
		this.ROUND(block, 6);  this.LT(block, b);
		this.ROUND(b,  8);  this.LT(b, block);
		this.ROUND(block, 10); this.LT(block, b);
		this.ROUND(b,  12); this.LT(b, block);
		this.ROUND(block, 14); this.LT(block, b);
		/* 192-bit key? */
		if (this.rounds > 8) {
			this.ROUND(b, 16);  this.LT(b, block);
			this.ROUND(block, 18); this.LT(block, b);
			this.ROUND(b, 20);  this.LT(b, block);
			this.ROUND(block, 22); this.LT(block, b);
		}
		/* 256-bit key? */
		if (this.rounds > 12) {
			this.ROUND(b, 24);  this.LT(b, block);
			this.ROUND(block, 26); this.LT(block, b);
			this.ROUND(b, 28);  this.LT(b, block);
			this.ROUND(block, 30); this.LT(block, b);
		}
		block[0] = b[0] ^ this.roundKeys[this.rounds*2][0];
		block[1] = (b[1] + this.roundKeys[this.rounds*2][1]) & 0xff;
		block[2] = (b[2] + this.roundKeys[this.rounds*2][2]) & 0xff;
		block[3] = b[3] ^ this.roundKeys[this.rounds*2][3];
		block[4] = b[4] ^ this.roundKeys[this.rounds*2][4];
		block[5] = (b[5] + this.roundKeys[this.rounds*2][5]) & 0xff;
		block[6] = (b[6] + this.roundKeys[this.rounds*2][6]) & 0xff;
		block[7] = b[7] ^ this.roundKeys[this.rounds*2][7];
		block[8] = b[8] ^ this.roundKeys[this.rounds*2][8];
		block[9] = (b[9] + this.roundKeys[this.rounds*2][9]) & 0xff;
		block[10] = (b[10] + this.roundKeys[this.rounds*2][10]) & 0xff;
		block[11] = b[11] ^ this.roundKeys[this.rounds*2][11];
		block[12] = b[12] ^ this.roundKeys[this.rounds*2][12];
		block[13] = (b[13] + this.roundKeys[this.rounds*2][13]) & 0xff;
		block[14] = (b[14] + this.roundKeys[this.rounds*2][14]) & 0xff;
		block[15] = b[15] ^ this.roundKeys[this.rounds*2][15];
		
		var out = this.swapWords(block);

		return out;
	}

	/**
	 * decrypts a block.
	 * 
	 * @public
	 * @param {buffer} input input data to be decrypted.
	 * @returns the decrypted block in buffer.
	 */
	decryptBlock(input)
	{
		var b = Buffer.alloc(input.length), pt = Buffer.alloc(input.length);
		var x;
		var ct = this.swapWords(input);

		/* do eight rounds */
		b[0] = ct[0] ^ this.roundKeys[this.rounds*2][0];
		b[1] = (ct[1] - this.roundKeys[this.rounds*2][1]) & 0xff;
		b[2] = (ct[2] - this.roundKeys[this.rounds*2][2]) & 0xff;
		b[3] = ct[3] ^ this.roundKeys[this.rounds*2][3];
		b[4] = ct[4] ^ this.roundKeys[this.rounds*2][4];
		b[5] = (ct[5] - this.roundKeys[this.rounds*2][5]) & 0xff;
		b[6] = (ct[6] - this.roundKeys[this.rounds*2][6]) & 0xff;
		b[7] = ct[7] ^ this.roundKeys[this.rounds*2][7];
		b[8] = ct[8] ^ this.roundKeys[this.rounds*2][8];
		b[9] = (ct[9] - this.roundKeys[this.rounds*2][9]) & 0xff;
		b[10] = (ct[10] - this.roundKeys[this.rounds*2][10]) & 0xff;
		b[11] = ct[11] ^ this.roundKeys[this.rounds*2][11];
		b[12] = ct[12] ^ this.roundKeys[this.rounds*2][12];
		b[13] = (ct[13] - this.roundKeys[this.rounds*2][13]) & 0xff;
		b[14] = (ct[14] - this.roundKeys[this.rounds*2][14]) & 0xff;
		b[15] = ct[15] ^ this.roundKeys[this.rounds*2][15];
		/* 256-bit key? */
		if (this.rounds > 12) {
			this.iLT(b, pt); this.iROUND(pt, 30);
			this.iLT(pt, b); this.iROUND(b, 28);
			this.iLT(b, pt); this.iROUND(pt, 26);
			this.iLT(pt, b); this.iROUND(b, 24);
		}
		/* 192-bit key? */
		if (this.rounds > 8) {
			this.iLT(b, pt); this.iROUND(pt, 22);
			this.iLT(pt, b); this.iROUND(b, 20);
			this.iLT(b, pt); this.iROUND(pt, 18);
			this.iLT(pt, b); this.iROUND(b, 16);
		}
		this.iLT(b, pt); this.iROUND(pt, 14);
		this.iLT(pt, b); this.iROUND(b, 12);
		this.iLT(b, pt); this.iROUND(pt,10);
		this.iLT(pt, b); this.iROUND(b, 8);
		this.iLT(b, pt); this.iROUND(pt,6);
		this.iLT(pt, b); this.iROUND(b, 4);
		this.iLT(b, pt); this.iROUND(pt,2);
		this.iLT(pt, b); this.iROUND(b, 0);

		var out = this.swapWords(b);
		return out;
	}

/*
 * -----------------
 * Private functions
 * -----------------
 */

	ROUND(b, i)
	{
		var ebox = jCastle.algorithm.saferplus.ebox, lbox = jCastle.algorithm.saferplus.lbox;

		for (var j = 0; j < 15; j += 4) {
			b[j    ]  = (ebox[(b[j   ] ^ this.roundKeys[i][j]) & 0xff] + this.roundKeys[i + 1][j]) & 0xff;
			b[j + 1]  = lbox[(b[j + 1] + this.roundKeys[i][j + 1]) & 0xff] ^ this.roundKeys[i + 1][j + 1];
			b[j + 2]  = lbox[(b[j + 2] + this.roundKeys[i][j + 2]) & 0xff] ^ this.roundKeys[i + 1][j + 2];
			b[j + 3]  = (ebox[(b[j + 3] ^ this.roundKeys[i][j + 3]) & 0xff] + this.roundKeys[i + 1][j + 3]) & 0xff;
		}

	}

	/* This is one inverse key application */
	iROUND(b, i)
	{
		var ebox = jCastle.algorithm.saferplus.ebox, lbox = jCastle.algorithm.saferplus.lbox;

		for (var j = 0; j < 15; j += 4) {
			b[j]  = lbox[(b[j         ] - this.roundKeys[i + 1][j]) & 0xff] ^ this.roundKeys[i][j];
			b[j + 1]  = (ebox[(b[j + 1] ^ this.roundKeys[i + 1][j + 1]) & 0xff] - this.roundKeys[i][j + 1]) & 0xff;
			b[j + 2]  = (ebox[(b[j + 2] ^ this.roundKeys[i + 1][j + 2]) & 0xff] - this.roundKeys[i][j + 2]) & 0xff;
			b[j + 3]  = lbox[(b[j + 3] - this.roundKeys[i + 1][j + 3]) & 0xff] ^ this.roundKeys[i][j + 3];
		}
	}

	/* This is a forward single layer PHT transform.  */
	PHT(b)
	{
		b[0]  = (b[0] + (b[1] = (b[0] + b[1]) & 0xff)) & 0xff;
		b[2]  = (b[2] + (b[3] = (b[3] + b[2]) & 0xff)) & 0xff;
		b[4]  = (b[4] + (b[5] = (b[5] + b[4]) & 0xff)) & 0xff;
		b[6]  = (b[6] + (b[7] = (b[7] + b[6]) & 0xff)) & 0xff;
		b[8]  = (b[8] + (b[9] = (b[9] + b[8]) & 0xff)) & 0xff;
		b[10] = (b[10] + (b[11] = (b[11] + b[10]) & 0xff)) & 0xff;
		b[12] = (b[12] + (b[13] = (b[13] + b[12]) & 0xff)) & 0xff;
		b[14] = (b[14] + (b[15] = (b[15] + b[14]) & 0xff)) & 0xff;
	}

	/* This is an inverse single layer PHT transform */
	iPHT(b)
	{
		b[15] = (b[15] - (b[14] = (b[14] - b[15]) & 0xff)) & 0xff;
		b[13] = (b[13] - (b[12] = (b[12] - b[13]) & 0xff)) & 0xff;
		b[11] = (b[11] - (b[10] = (b[10] - b[11]) & 0xff)) & 0xff;
		b[9]  = (b[9] - (b[8] = (b[8] - b[9]) & 0xff)) & 0xff;
		b[7]  = (b[7] - (b[6] = (b[6] - b[7]) & 0xff)) & 0xff;
		b[5]  = (b[5] - (b[4] = (b[4] - b[5]) & 0xff)) & 0xff;
		b[3]  = (b[3] - (b[2] = (b[2] - b[3]) & 0xff)) & 0xff;
		b[1]  = (b[1] - (b[0] = (b[0] - b[1]) & 0xff)) & 0xff;
	}

	/* This is the "Armenian" Shuffle.  It takes the input from b and stores it in b2 */
	SHUF(b, b2)
	{
		b2[0] = b[8]; b2[1] = b[11]; b2[2] = b[12]; b2[3] = b[15];
		b2[4] = b[2]; b2[5] = b[1]; b2[6] = b[6]; b2[7] = b[5];
		b2[8] = b[10]; b2[9] = b[9]; b2[10] = b[14]; b2[11] = b[13];
		b2[12] = b[0]; b2[13] = b[7]; b2[14] = b[4]; b2[15] = b[3];
	}

	/* This is the inverse shuffle.  It takes from b and gives to b2 */
	iSHUF(b, b2)
	{
		b2[0] = b[12]; b2[1] = b[5]; b2[2] = b[4]; b2[3] = b[15];
		b2[4] = b[14]; b2[5] = b[7]; b2[6] = b[6]; b2[7] = b[13];
		b2[8] = b[0]; b2[9] = b[9]; b2[10] = b[8]; b2[11] = b[1];
		b2[12] = b[2]; b2[13] = b[11]; b2[14] = b[10]; b2[15] = b[3];
	}

	/* The complete forward Linear Transform layer.  
	 * Note that alternating usage of b and b2.  
	 * Each round of LT starts in 'b' and ends in 'b2'.  
	 */
	LT(b, b2)
	{
		this.PHT(b);  this.SHUF(b, b2);
		this.PHT(b2); this.SHUF(b2, b);
		this.PHT(b);  this.SHUF(b, b2);
		this.PHT(b2);
	}

	/* This is the inverse linear transform layer.  */
	iLT(b, b2)
	{
		this.iPHT(b);
		this.iSHUF(b, b2); this.iPHT(b2);
		this.iSHUF(b2, b); this.iPHT(b);
		this.iSHUF(b, b2); this.iPHT(b2);
	}

	/**
	 * Calculate the necessary round keys.
	 * The number of calculations depends on key size and block size.
	 * 
	 * @private
	 * @param {buffer} key key for encryption/decryption.
	 * @param {boolean} isEncryption true if it is encryption, otherwise false.
	 */
	expandKey(key, isEncryption)
	{
		var x, y, z;
		var t = [];// unsigned char: 33
		var rounds = [8, 12, 16];
		var swapKey = this.swapWords(key);
		var keylen = swapKey.length;

		// initialize roundKeys [33][16]
		this.roundKeys = [];
		for (var i = 0; i < 33; i++) {
			this.roundKeys[i] = new Array(16);
		}

		/* Is the number of rounds valid?  Either use zero for default or
		* 8,12,16 rounds for 16,24,32 byte keys 
		*/
		var num_rounds = rounds[(keylen / 8) - 2];

		/* 128 bit key version */
		if (keylen == 16) {
			/* copy key into t */
			for (x = y = 0; x < 16; x++) { 
				t[x] = swapKey[x]; 
				y ^= swapKey[x]; 
			}
			t[16] = y;

			/* make round keys */
			for (x = 0; x < 16; x++) {
				this.roundKeys[0][x] = t[x];
			}

			/* make the 16 other keys as a transformation of the first key */
			for (x = 1; x < 17; x++) {
				/* rotate 3 bits each */
				for (y = 0; y < 17; y++) {
					t[y] = ((t[y] << 3)|(t[y] >>> 5)) & 0xFF;
				}

				/* select and add */
				z = x;
				for (y = 0; y < 16; y++) {
					this.roundKeys[x][y] = (t[z] + jCastle.algorithm.saferplus.bias[x - 1][y]) & 0xFF;
					if (++z == 17) { z = 0; }
				}
			}
			this.rounds = 8;
		} else if (keylen == 24) {
			/* copy key into t */
			for (x = y = 0; x < 24; x++) { 
				t[x] = swapKey[x]; 
				y ^= swapKey[x]; 
			}
			t[24] = y;

			/* make round keys */
			for (x = 0; x < 16; x++) {
				this.roundKeys[0][x] = t[x];
			}

			for (x = 1; x < 25; x++) {
				/* rotate 3 bits each */
				for (y = 0; y < 25; y++) {
					t[y] = ((t[y] << 3)|(t[y] >>> 5)) & 0xFF;
				}

				/* select and add */
				z = x;
				for (y = 0; y < 16; y++) { 
					this.roundKeys[x][y] = (t[z] + jCastle.algorithm.saferplus.bias[x - 1][y]) & 0xFF;
					if (++z == 25) { z = 0; }
				}
			}
			this.rounds = 12;
		} else {
			/* copy key into t */
			for (x = y = 0; x < 32; x++) { 
				t[x] = swapKey[x]; 
				y ^= swapKey[x]; 
			}
			t[32] = y;

			/* make round keys */
			for (x = 0; x < 16; x++) { 
				this.roundKeys[0][x] = t[x];
			}

			for (x = 1; x < 33; x++) {
				/* rotate 3 bits each */
				for (y = 0; y < 33; y++) {
					t[y] = ((t[y] << 3)|(t[y] >>> 5)) & 0xFF;
				}
			   
				/* select and add */
				z = x;
				for (y = 0; y < 16; y++) {
					this.roundKeys[x][y] = (t[z] + jCastle.algorithm.saferplus.bias[x - 1][y]) & 0xFF;
					if (++z == 33) { z = 0; }
				}
			}
			this.rounds = 16;
		}
	}

	swapWords(block)
	{
		var i = 0, j = block.length -4;
		var tmp = Buffer.alloc(block.length);
		
		while (i < block.length) {
			tmp[i] = block[j] & 0xFF;
			tmp[i+1] = block[j+1] & 0xFF;
			tmp[i+2] = block[j+2] & 0xFF;
			tmp[i+3] = block[j+3] & 0xFF;
			i += 4;
			j -= 4;
		}
		
		return tmp;
	}
}



/*
 * ---------
 * Constants
 * ---------
 */

jCastle.algorithm.saferplus.ebox = [
	0x01, 0x2d, 0xe2, 0x93, 0xbe, 0x45, 0x15, 0xae, 0x78, 0x03, 
	0x87, 0xa4, 0xb8, 0x38, 0xcf, 0x3f, 0x08, 0x67, 0x09, 0x94, 
	0xeb, 0x26, 0xa8, 0x6b, 0xbd, 0x18, 0x34, 0x1b, 0xbb, 0xbf, 
	0x72, 0xf7, 0x40, 0x35, 0x48, 0x9c, 0x51, 0x2f, 0x3b, 0x55, 
	0xe3, 0xc0, 0x9f, 0xd8, 0xd3, 0xf3, 0x8d, 0xb1, 0xff, 0xa7, 
	0x3e, 0xdc, 0x86, 0x77, 0xd7, 0xa6, 0x11, 0xfb, 0xf4, 0xba, 
	0x92, 0x91, 0x64, 0x83, 0xf1, 0x33, 0xef, 0xda, 0x2c, 0xb5, 
	0xb2, 0x2b, 0x88, 0xd1, 0x99, 0xcb, 0x8c, 0x84, 0x1d, 0x14, 
	0x81, 0x97, 0x71, 0xca, 0x5f, 0xa3, 0x8b, 0x57, 0x3c, 0x82, 
	0xc4, 0x52, 0x5c, 0x1c, 0xe8, 0xa0, 0x04, 0xb4, 0x85, 0x4a, 
	0xf6, 0x13, 0x54, 0xb6, 0xdf, 0x0c, 0x1a, 0x8e, 0xde, 0xe0, 
	0x39, 0xfc, 0x20, 0x9b, 0x24, 0x4e, 0xa9, 0x98, 0x9e, 0xab, 
	0xf2, 0x60, 0xd0, 0x6c, 0xea, 0xfa, 0xc7, 0xd9, 0x00, 0xd4, 
	0x1f, 0x6e, 0x43, 0xbc, 0xec, 0x53, 0x89, 0xfe, 0x7a, 0x5d, 
	0x49, 0xc9, 0x32, 0xc2, 0xf9, 0x9a, 0xf8, 0x6d, 0x16, 0xdb, 
	0x59, 0x96, 0x44, 0xe9, 0xcd, 0xe6, 0x46, 0x42, 0x8f, 0x0a, 
	0xc1, 0xcc, 0xb9, 0x65, 0xb0, 0xd2, 0xc6, 0xac, 0x1e, 0x41, 
	0x62, 0x29, 0x2e, 0x0e, 0x74, 0x50, 0x02, 0x5a, 0xc3, 0x25, 
	0x7b, 0x8a, 0x2a, 0x5b, 0xf0, 0x06, 0x0d, 0x47, 0x6f, 0x70, 
	0x9d, 0x7e, 0x10, 0xce, 0x12, 0x27, 0xd5, 0x4c, 0x4f, 0xd6, 
	0x79, 0x30, 0x68, 0x36, 0x75, 0x7d, 0xe4, 0xed, 0x80, 0x6a, 
	0x90, 0x37, 0xa2, 0x5e, 0x76, 0xaa, 0xc5, 0x7f, 0x3d, 0xaf, 
	0xa5, 0xe5, 0x19, 0x61, 0xfd, 0x4d, 0x7c, 0xb7, 0x0b, 0xee, 
	0xad, 0x4b, 0x22, 0xf5, 0xe7, 0x73, 0x23, 0x21, 0xc8, 0x05, 
	0xe1, 0x66, 0xdd, 0xb3, 0x58, 0x69, 0x63, 0x56, 0x0f, 0xa1, 
	0x31, 0x95, 0x17, 0x07, 0x3a, 0x28
];

/* This is the inverse of ebox or the base 45 logarithm */
jCastle.algorithm.saferplus.lbox = [
	0x80, 0x00, 0xb0, 0x09, 0x60, 0xef, 0xb9, 0xfd, 0x10, 0x12, 
	0x9f, 0xe4, 0x69, 0xba, 0xad, 0xf8, 0xc0, 0x38, 0xc2, 0x65, 
	0x4f, 0x06, 0x94, 0xfc, 0x19, 0xde, 0x6a, 0x1b, 0x5d, 0x4e, 
	0xa8, 0x82, 0x70, 0xed, 0xe8, 0xec, 0x72, 0xb3, 0x15, 0xc3, 
	0xff, 0xab, 0xb6, 0x47, 0x44, 0x01, 0xac, 0x25, 0xc9, 0xfa, 
	0x8e, 0x41, 0x1a, 0x21, 0xcb, 0xd3, 0x0d, 0x6e, 0xfe, 0x26, 
	0x58, 0xda, 0x32, 0x0f, 0x20, 0xa9, 0x9d, 0x84, 0x98, 0x05, 
	0x9c, 0xbb, 0x22, 0x8c, 0x63, 0xe7, 0xc5, 0xe1, 0x73, 0xc6, 
	0xaf, 0x24, 0x5b, 0x87, 0x66, 0x27, 0xf7, 0x57, 0xf4, 0x96, 
	0xb1, 0xb7, 0x5c, 0x8b, 0xd5, 0x54, 0x79, 0xdf, 0xaa, 0xf6, 
	0x3e, 0xa3, 0xf1, 0x11, 0xca, 0xf5, 0xd1, 0x17, 0x7b, 0x93, 
	0x83, 0xbc, 0xbd, 0x52, 0x1e, 0xeb, 0xae, 0xcc, 0xd6, 0x35, 
	0x08, 0xc8, 0x8a, 0xb4, 0xe2, 0xcd, 0xbf, 0xd9, 0xd0, 0x50, 
	0x59, 0x3f, 0x4d, 0x62, 0x34, 0x0a, 0x48, 0x88, 0xb5, 0x56, 
	0x4c, 0x2e, 0x6b, 0x9e, 0xd2, 0x3d, 0x3c, 0x03, 0x13, 0xfb, 
	0x97, 0x51, 0x75, 0x4a, 0x91, 0x71, 0x23, 0xbe, 0x76, 0x2a, 
	0x5f, 0xf9, 0xd4, 0x55, 0x0b, 0xdc, 0x37, 0x31, 0x16, 0x74, 
	0xd7, 0x77, 0xa7, 0xe6, 0x07, 0xdb, 0xa4, 0x2f, 0x46, 0xf3, 
	0x61, 0x45, 0x67, 0xe3, 0x0c, 0xa2, 0x3b, 0x1c, 0x85, 0x18, 
	0x04, 0x1d, 0x29, 0xa0, 0x8f, 0xb2, 0x5a, 0xd8, 0xa6, 0x7e, 
	0xee, 0x8d, 0x53, 0x4b, 0xa1, 0x9a, 0xc1, 0x0e, 0x7a, 0x49, 
	0xa5, 0x2c, 0x81, 0xc4, 0xc7, 0x36, 0x2b, 0x7f, 0x43, 0x95, 
	0x33, 0xf2, 0x6c, 0x68, 0x6d, 0xf0, 0x02, 0x28, 0xce, 0xdd, 
	0x9b, 0xea, 0x5e, 0x99, 0x7c, 0x14, 0x86, 0xcf, 0xe5, 0x42, 
	0xb8, 0x40, 0x78, 0x2d, 0x3a, 0xe9, 0x64, 0x1f, 0x92, 0x90, 
	0x7d, 0x39, 0x6f, 0xe0, 0x89, 0x30
];


/* These are the 33, 128-bit bias words for the key schedule */
jCastle.algorithm.saferplus.bias = [
	[0x46, 0x97, 0xb1, 0xba, 0xa3, 0xb7, 0x10, 0x0a, 0xc5, 0x37, 0xb3, 0xc9, 0x5a, 0x28, 0xac, 0x64],
	[0xec, 0xab, 0xaa, 0xc6, 0x67, 0x95, 0x58, 0x0d, 0xf8, 0x9a, 0xf6, 0x6e, 0x66, 0xdc, 0x05, 0x3d],
	[0x8a, 0xc3, 0xd8, 0x89, 0x6a, 0xe9, 0x36, 0x49, 0x43, 0xbf, 0xeb, 0xd4, 0x96, 0x9b, 0x68, 0xa0],
	[0x5d, 0x57, 0x92, 0x1f, 0xd5, 0x71, 0x5c, 0xbb, 0x22, 0xc1, 0xbe, 0x7b, 0xbc, 0x99, 0x63, 0x94],
	[0x2a, 0x61, 0xb8, 0x34, 0x32, 0x19, 0xfd, 0xfb, 0x17, 0x40, 0xe6, 0x51, 0x1d, 0x41, 0x44, 0x8f],
	[0xdd, 0x04, 0x80, 0xde, 0xe7, 0x31, 0xd6, 0x7f, 0x01, 0xa2, 0xf7, 0x39, 0xda, 0x6f, 0x23, 0xca],
	[0x3a, 0xd0, 0x1c, 0xd1, 0x30, 0x3e, 0x12, 0xa1, 0xcd, 0x0f, 0xe0, 0xa8, 0xaf, 0x82, 0x59, 0x2c],
	[0x7d, 0xad, 0xb2, 0xef, 0xc2, 0x87, 0xce, 0x75, 0x06, 0x13, 0x02, 0x90, 0x4f, 0x2e, 0x72, 0x33],
	[0xc0, 0x8d, 0xcf, 0xa9, 0x81, 0xe2, 0xc4, 0x27, 0x2f, 0x6c, 0x7a, 0x9f, 0x52, 0xe1, 0x15, 0x38],
	[0xfc, 0x20, 0x42, 0xc7, 0x08, 0xe4, 0x09, 0x55, 0x5e, 0x8c, 0x14, 0x76, 0x60, 0xff, 0xdf, 0xd7],
	[0xfa, 0x0b, 0x21, 0x00, 0x1a, 0xf9, 0xa6, 0xb9, 0xe8, 0x9e, 0x62, 0x4c, 0xd9, 0x91, 0x50, 0xd2],
	[0x18, 0xb4, 0x07, 0x84, 0xea, 0x5b, 0xa4, 0xc8, 0x0e, 0xcb, 0x48, 0x69, 0x4b, 0x4e, 0x9c, 0x35],
	[0x45, 0x4d, 0x54, 0xe5, 0x25, 0x3c, 0x0c, 0x4a, 0x8b, 0x3f, 0xcc, 0xa7, 0xdb, 0x6b, 0xae, 0xf4],
	[0x2d, 0xf3, 0x7c, 0x6d, 0x9d, 0xb5, 0x26, 0x74, 0xf2, 0x93, 0x53, 0xb0, 0xf0, 0x11, 0xed, 0x83],
	[0xb6, 0x03, 0x16, 0x73, 0x3b, 0x1e, 0x8e, 0x70, 0xbd, 0x86, 0x1b, 0x47, 0x7e, 0x24, 0x56, 0xf1],
	[0x88, 0x46, 0x97, 0xb1, 0xba, 0xa3, 0xb7, 0x10, 0x0a, 0xc5, 0x37, 0xb3, 0xc9, 0x5a, 0x28, 0xac],
	[0xdc, 0x86, 0x77, 0xd7, 0xa6, 0x11, 0xfb, 0xf4, 0xba, 0x92, 0x91, 0x64, 0x83, 0xf1, 0x33, 0xef],
	[0x2c, 0xb5, 0xb2, 0x2b, 0x88, 0xd1, 0x99, 0xcb, 0x8c, 0x84, 0x1d, 0x14, 0x81, 0x97, 0x71, 0xca],
	[0xa3, 0x8b, 0x57, 0x3c, 0x82, 0xc4, 0x52, 0x5c, 0x1c, 0xe8, 0xa0, 0x04, 0xb4, 0x85, 0x4a, 0xf6],
	[0x54, 0xb6, 0xdf, 0x0c, 0x1a, 0x8e, 0xde, 0xe0, 0x39, 0xfc, 0x20, 0x9b, 0x24, 0x4e, 0xa9, 0x98],
	[0xab, 0xf2, 0x60, 0xd0, 0x6c, 0xea, 0xfa, 0xc7, 0xd9, 0x00, 0xd4, 0x1f, 0x6e, 0x43, 0xbc, 0xec],
	[0x89, 0xfe, 0x7a, 0x5d, 0x49, 0xc9, 0x32, 0xc2, 0xf9, 0x9a, 0xf8, 0x6d, 0x16, 0xdb, 0x59, 0x96],
	[0xe9, 0xcd, 0xe6, 0x46, 0x42, 0x8f, 0x0a, 0xc1, 0xcc, 0xb9, 0x65, 0xb0, 0xd2, 0xc6, 0xac, 0x1e],
	[0x62, 0x29, 0x2e, 0x0e, 0x74, 0x50, 0x02, 0x5a, 0xc3, 0x25, 0x7b, 0x8a, 0x2a, 0x5b, 0xf0, 0x06],
	[0x47, 0x6f, 0x70, 0x9d, 0x7e, 0x10, 0xce, 0x12, 0x27, 0xd5, 0x4c, 0x4f, 0xd6, 0x79, 0x30, 0x68],
	[0x75, 0x7d, 0xe4, 0xed, 0x80, 0x6a, 0x90, 0x37, 0xa2, 0x5e, 0x76, 0xaa, 0xc5, 0x7f, 0x3d, 0xaf],
	[0xe5, 0x19, 0x61, 0xfd, 0x4d, 0x7c, 0xb7, 0x0b, 0xee, 0xad, 0x4b, 0x22, 0xf5, 0xe7, 0x73, 0x23],
	[0xc8, 0x05, 0xe1, 0x66, 0xdd, 0xb3, 0x58, 0x69, 0x63, 0x56, 0x0f, 0xa1, 0x31, 0x95, 0x17, 0x07],
	[0x28, 0x01, 0x2d, 0xe2, 0x93, 0xbe, 0x45, 0x15, 0xae, 0x78, 0x03, 0x87, 0xa4, 0xb8, 0x38, 0xcf],
	[0x08, 0x67, 0x09, 0x94, 0xeb, 0x26, 0xa8, 0x6b, 0xbd, 0x18, 0x34, 0x1b, 0xbb, 0xbf, 0x72, 0xf7],
	[0x35, 0x48, 0x9c, 0x51, 0x2f, 0x3b, 0x55, 0xe3, 0xc0, 0x9f, 0xd8, 0xd3, 0xf3, 0x8d, 0xb1, 0xff],
	[0x3e, 0xdc, 0x86, 0x77, 0xd7, 0xa6, 0x11, 0xfb, 0xf4, 0xba, 0x92, 0x91, 0x64, 0x83, 0xf1, 0x33]
];

jCastle.algorithm.saferPlus = jCastle.algorithm.saferplus;

jCastle._algorithmInfo['saferplus'] = {
	algorithm_type: 'crypt',
	block_size: 16,
	key_size: 32,
	min_key_size: 16,
	max_key_size: 32,
	key_sizes: [16, 24, 32],
	padding: 'zeros',
	object_name: 'saferplus'
};

module.exports = jCastle.algorithm.saferplus;