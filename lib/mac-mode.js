/**
 * jCastle - Mac-Mode: Javascript Mac Modes 
 * 
 * @author Jacob Lee
 *
 * Copyright (C) 2015-2021 Jacob Lee.
 */

var jCastle = require('./jCastle');
require('./mcrypt');
require('./mcrypt-mode');
require('./mac');

jCastle.mac.mode = {};

/**
 * gets the list of mac modes.
 * 
 * @public
 * @returns the arrays of mac modes.
 */
jCastle.mac.mode.listModes = function()
{
	var l = [
		'cmac', 'cbc-mac', 'gmac', 'gost28147-mac', 
		'des-ede-mac', // 'iso9797alg3-mac', 'tripledes-mac',
		'vmpc-mac', 'cfb-mac', 'ploy1305-mac'
	];
	return l;
};
 

/**
 * creates a new mac-mode class.
 * 
 * @public
 * @param {string} mode mac mode name.
 * @returns the mac-mode class
 */
jCastle.mac.mode.create = function(mode)
{
	return new jCastle.mac.mode[mode.toLowerCase()];
};

/*
https://tools.ietf.org/html/rfc4493

   CMAC is equivalent to the One-Key CBC MAC1 (OMAC1)
   submitted by Iwata and Kurosawa [OMAC1a, OMAC1b].  OMAC1 is an
   improvement of the eXtended Cipher Block Chaining mode (XCBC)
   submitted by Black and Rogaway [XCBCa, XCBCb], which itself is an
   improvement of the basic Cipher Block Chaining-Message Authentication
   Code (CBC-MAC).  XCBC efficiently addresses the security deficiencies
   of CBC-MAC, and OMAC1 efficiently reduces the key size of XCBC.
*/

jCastle.mac.mode['cmac'] = class
{
    constructor()
    {
        this.cbcMode = null;
        this.blockSize = 0;
        this.algorithm = null;
        this.mac = null;

        this.CONST_128 = 0x87;
        this.CONST_64  = 0x1b;
    }

/*
RFC 4493

2.2.  Overview

   AES-CMAC uses the Advanced Encryption Standard [NIST-AES] as a
   building block.  To generate a MAC, AES-CMAC takes a secret key, a
   message of variable length, and the length of the message in octets
   as inputs and returns a fixed-bit string called a MAC.

   The core of AES-CMAC is the basic CBC-MAC.  For a message, M, to be
   authenticated, the CBC-MAC is applied to M.  There are two cases of
   operation in CMAC.  Figure 2.1 illustrates the operation of CBC-MAC
   in both cases.  If the size of the input message block is equal to a
   positive multiple of the block size (namely, 128 bits), the last
   block shall be exclusive-OR'ed with K1 before processing.  Otherwise,
   the last block shall be padded with 10^i (notation is described in
   section 2.1) and exclusive-OR'ed with K2.  The result of the previous
   process will be the input of the last encryption.  The output of
   AES-CMAC provides data integrity of the whole input message.

 +-----+	 +-----+	 +-----+	 +-----+	 +-----+	 +---+----+
 | M_1 |	 | M_2 |	 | M_n |	 | M_1 |	 | M_2 |	 |M_n|10^i|
 +-----+	 +-----+	 +-----+	 +-----+	 +-----+	 +---+----+
	|		   |		   |   +--+	|		   |		   |   +--+
	|	 +--->(+)	+--->(+)<-|K1|	|	 +--->(+)	+--->(+)<-|K2|
	|	 |	 |	 |	 |   +--+	|	 |	 |	 |	 |   +--+
 +-----+  |  +-----+  |  +-----+	 +-----+  |  +-----+  |  +-----+
 |AES_K|  |  |AES_K|  |  |AES_K|	 |AES_K|  |  |AES_K|  |  |AES_K|
 +-----+  |  +-----+  |  +-----+	 +-----+  |  +-----+  |  +-----+
	|	 |	 |	 |	 |		   |	 |	 |	 |	 |
	+-----+	 +-----+	 |		   +-----+	 +-----+	 |
							|								   |
						 +-----+							  +-----+
						 |  T  |							  |  T  |
						 +-----+							  +-----+

			 (a) positive multiple block length		 (b) otherwise

		  Figure 2.1.  Illustration of the two cases of AES-CMAC

   AES_K is AES-128 with key K.
   The message M is divided into blocks M_1,...,M_n,
   where M_i is the i-th message block.
   The length of M_i is 128 bits for i = 1,...,n-1, and
   the length of the last block, M_n, is less than or equal to 128 bits.
   K1 is the subkey for the case (a), and
   K2 is the subkey for the case (b).
   K1 and K2 are generated by the subkey generation algorithm
   described in section 2.3.
*/
	init(algorithm, options)
	{
		if (!algorithm) {
			throw jCastle.exception('ALGORITHM_NOT_SET', 'MAC003');
		}

		this.algorithm = algorithm;
		this.blockSize = 'blockSize' in options ? options.blockSize : jCastle._algorithmInfo[this.algorithm.algoName].block_size;

		if (this.blockSize != 16 && this.blockSize != 8) {
			throw jCastle.exception('INVALID_BLOCKSIZE', 'MAC004');
		}

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		this.algorithm.keySchedule(key, true);

		// cMac does use zero iv.
		var zero_block = Buffer.alloc(this.blockSize, 0x00);

		var cbc_options = {
			iv: zero_block.slice(0),
			blockSize: this.blockSize,
			isEncryption: true
		};
		this.cbcMode = jCastle.mcrypt.mode.create('cbc');
		this.cbcMode.init(this.algorithm, cbc_options);

		var L = this.cbcMode.process(zero_block);
		this.key1 = this.generateSubKey(L);
		this.key2 = this.generateSubKey(this.key1);

		this.cbcMode.init(this.algorithm, cbc_options);

		// the last block will be xor with key1 or key2
		// therefore we will save one block before processing.
		this.state = Buffer.alloc(0);
	}

/*
2.3.  Subkey Generation Algorithm

   The subkey generation algorithm, Generate_Subkey(), takes a secret
   key, K, which is just the key for AES-128.

   The outputs of the subkey generation algorithm are two subkeys, K1
   and K2.  We write (K1,K2) := Generate_Subkey(K).

   Subkeys K1 and K2 are used in both MAC generation and MAC
   verification algorithms.  K1 is used for the case where the length of
   the last block is equal to the block length.  K2 is used for the case
   where the length of the last block is less than the block length.

   Figure 2.2 specifies the subkey generation algorithm.

   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +					Algorithm Generate_Subkey					  +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +																   +
   +   Input	: K (128-bit key)									  +
   +   Output   : K1 (128-bit first subkey)							+
   +			  K2 (128-bit second subkey)						   +
   +-------------------------------------------------------------------+
   +																   +
   +   Constants: const_Zero is 0x00000000000000000000000000000000	 +
   +			  const_Rb   is 0x00000000000000000000000000000087	 +
   +   Variables: L		  for output of AES-128 applied to 0^128	+
   +																   +
   +   Step 1.  L := AES-128(K, const_Zero);						   +
   +   Step 2.  if MSB(L) is equal to 0								+
   +			then	K1 := L << 1;								  +
   +			else	K1 := (L << 1) XOR const_Rb;				   +
   +   Step 3.  if MSB(K1) is equal to 0							   +
   +			then	K2 := K1 << 1;								 +
   +			else	K2 := (K1 << 1) XOR const_Rb;				  +
   +   Step 4.  return K1, K2;										 +
   +																   +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

				Figure 2.2.  Algorithm Generate_Subkey

   In step 1, AES-128 with key K is applied to an all-zero input block.

   In step 2, K1 is derived through the following operation:

   If the most significant bit of L is equal to 0, K1 is the left-shift
   of L by 1 bit.

   Otherwise, K1 is the exclusive-OR of const_Rb and the left-shift of L
   by 1 bit.

   In step 3, K2 is derived through the following operation:

   If the most significant bit of K1 is equal to 0, K2 is the left-shift
   of K1 by 1 bit.

   Otherwise, K2 is the exclusive-OR of const_Rb and the left-shift of
   K1 by 1 bit.

   In step 4, (K1,K2) := Generate_Subkey(K) is returned.

   The mathematical meaning of the procedures in steps 2 and 3,
   including const_Rb, can be found in [OMAC1a].

*/
	generateSubKey(input)
	{
		var first_bit = (input[0] & 0xff) >>> 7;
		var ret = Buffer.alloc(input.length);

		for (var i = 0; i < input.length - 1; i++) {
			ret[i] = ((input[i] << 1) + ((input[i + 1] & 0xff) >>> 7)) & 0xff;
		}

		ret[input.length - 1] = (input[input.length - 1] << 1) & 0xff;

		if (first_bit == 1) {
			ret[input.length - 1] ^= input.length == 16 ? this.CONST_128 : this.CONST_64;
		}

		return ret;
	}

	process(input)
	{
		if (this.state.length) {
			this.mac = this.cbcMode.process(this.state);
		}
		this.state = Buffer.slice(input);
	}

/*
2.4.  MAC Generation Algorithm

   The MAC generation algorithm, AES-CMAC(), takes three inputs, a
   secret key, a message, and the length of the message in octets.  The
   secret key, denoted by K, is just the key for AES-128.  The message
   and its length in octets are denoted by M and len, respectively.  The
   message M is denoted by the sequence of M_i, where M_i is the i-th
   message block.  That is, if M consists of n blocks, then M is written
   as

	-   M = M_1 || M_2 || ... || M_{n-1} || M_n

   The length of M_i is 128 bits for i = 1,...,n-1, and the length of
   the last block M_n is less than or equal to 128 bits.

   The output of the MAC generation algorithm is a 128-bit string,
   called a MAC, which is used to validate the input message.  The MAC
   is denoted by T, and we write T := AES-CMAC(K,M,len).  Validating the
   MAC provides assurance of the integrity and authenticity of the
   message from the source.

   It is possible to truncate the MAC.  According to [NIST-CMAC], at
   least a 64-bit MAC should be used as protection against guessing
   attacks.  The result of truncation should be taken in most
   significant bits first order.

   The block length of AES-128 is 128 bits (16 octets).  There is a
   special treatment if the length of the message is not a positive
   multiple of the block length.  The special treatment is to pad M with
   the bit-string 10^i to adjust the length of the last block up to the
   block length.

   For an input string x of r-octets, where 0 <= r < 16, the padding
   function, padding(x), is defined as follows:

   -   padding(x) = x || 10^i	  where i is 128-8*r-1

   That is, padding(x) is the concatenation of x and a single '1',
   followed by the minimum number of '0's, so that the total length is
   equal to 128 bits.

   Figure 2.3 describes the MAC generation algorithm.

   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +				   Algorithm AES-CMAC							  +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +																   +
   +   Input	: K	( 128-bit key )								 +
   +			: M	( message to be authenticated )				 +
   +			: len  ( length of the message in octets )			 +
   +   Output   : T	( message authentication code )				 +
   +																   +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +   Constants: const_Zero is 0x00000000000000000000000000000000	 +
   +			  const_Bsize is 16									+
   +																   +
   +   Variables: K1, K2 for 128-bit subkeys						   +
   +			  M_i is the i-th block (i=1..ceil(len/const_Bsize))   +
   +			  M_last is the last block xor-ed with K1 or K2		+
   +			  n	  for number of blocks to be processed		  +
   +			  r	  for number of octets of last block			+
   +			  flag   for denoting if last block is complete or not +
   +																   +
   +   Step 1.  (K1,K2) := Generate_Subkey(K);						 +
   +   Step 2.  n := ceil(len/const_Bsize);							+
   +   Step 3.  if n = 0											   +
   +			then												   +
   +				 n := 1;										   +
   +				 flag := false;									+
   +			else												   +
   +				 if len mod const_Bsize is 0					   +
   +				 then flag := true;								+
   +				 else flag := false;							   +
   +																   +
   +   Step 4.  if flag is true										+
   +			then M_last := M_n XOR K1;							 +
   +			else M_last := padding(M_n) XOR K2;					+
   +   Step 5.  X := const_Zero;									   +
   +   Step 6.  for i := 1 to n-1 do								   +
   +				begin											  +
   +				  Y := X XOR M_i;								  +
   +				  X := AES-128(K,Y);							   +
   +				end												+
   +			Y := M_last XOR X;									 +
   +			T := AES-128(K,Y);									 +
   +   Step 7.  return T;											  +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

					  Figure 2.3.  Algorithm AES-CMAC

   In step 1, subkeys K1 and K2 are derived from K through the subkey
   generation algorithm.

   In step 2, the number of blocks, n, is calculated.  The number of
   blocks is the smallest integer value greater than or equal to the
   quotient determined by dividing the length parameter by the block
   length, 16 octets.

   In step 3, the length of the input message is checked.  If the input
   length is 0 (null), the number of blocks to be processed shall be 1,
   and the flag shall be marked as not-complete-block (false).
   Otherwise, if the last block length is 128 bits, the flag is marked
   as complete-block (true); else mark the flag as not-complete-block
   (false).

   In step 4, M_last is calculated by exclusive-OR'ing M_n and one of
   the previously calculated subkeys.  If the last block is a complete
   block (true), then M_last is the exclusive-OR of M_n and K1.
   Otherwise, M_last is the exclusive-OR of padding(M_n) and K2.

   In step 5, the variable X is initialized.

   In step 6, the basic CBC-MAC is applied to M_1,...,M_{n-1},M_last.

   In step 7, the 128-bit MAC, T := AES-CMAC(K,M,len), is returned.

   If necessary, the MAC is truncated before it is returned.
*/
	finish()
	{
		if (this.blockSize == this.state.length) {
			var key = this.key1;
		} else {
			var key = this.key2;
			this.state = jCastle.mcrypt.padding.create('iso7816').pad(this.state, this.blockSize);
		}

		for (var i = 0; i < this.blockSize; i++) {
			this.state[i] ^= key[i];
		}

		this.mac = this.cbcMode.process(this.state);

		this.reset();

		return Buffer.slice(this.mac);
	}

/*
2.5.  MAC Verification Algorithm

   The verification of the MAC is simply done by a MAC recomputation.
   We use the MAC generation algorithm, which is described in section
   2.4.

   The MAC verification algorithm, Verify_MAC(), takes four inputs, a
   secret key, a message, the length of the message in octets, and the
   received MAC.  These are denoted by K, M, len, and T', respectively.

   The output of the MAC verification algorithm is either INVALID or
   VALID.

   Figure 2.4 describes the MAC verification algorithm.


   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +					  Algorithm Verify_MAC						 +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +																   +
   +   Input	: K	( 128-bit Key )								 +
   +			: M	( message to be verified )					  +
   +			: len  ( length of the message in octets )			 +
   +			: T'   ( the received MAC to be verified )			 +
   +   Output   : INVALID or VALID									 +
   +																   +
   +-------------------------------------------------------------------+
   +																   +
   +   Step 1.  T* := AES-CMAC(K,M,len);							   +
   +   Step 2.  if T* is equal to T'								   +
   +			then												   +
   +				 return VALID;									 +
   +			else												   +
   +				 return INVALID;								   +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

					Figure 2.4.  Algorithm Verify_MAC

   In step 1, T* is derived from K, M, and len through the MAC
   generation algorithm.

   In step 2, T* and T' are compared.  If T* is equal to T', then return
   VALID; otherwise return INVALID.

   If the output is INVALID, then the message is definitely not
   authentic, i.e., it did not originate from a source that executed the
   generation process on the message to produce the purported MAC.

   If the output is VALID, then the design of the AES-CMAC provides
   assurance that the message is authentic and, hence, was not corrupted
   in transit; however, this assurance, as for any MAC algorithm, is not
   absolute.
*/

	reset(no_reset)
	{
		this.cbcMode = null;
		this.blockSize = 0;
		this.state = null;

		if (no_reset && typeof this.algorithm.reset === 'function') {
			this.algorithm.reset();
		}
		this.algorithm = null;
	}

} /* the end of CMac */


jCastle.mac.mode['cbc-mac'] = class
{
    constructor()
    {
        this.cbcMode = null;
        this.blockSize = 0;
        this.algorithm = null;
        this.mac = null;
        this.state = null;
    }

	init(algorithm, options)
	{
		if (!algorithm) {
			throw jCastle.exception('ALGORITHM_NOT_SET', 'MAC005');
		}

		this.algorithm = algorithm;
		this.blockSize = 'blockSize' in options ? options.blockSize : jCastle._algorithmInfo[this.algorithm.algoName].block_size;

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		this.cbcMode = jCastle.mcrypt.mode.create('cbc');

		this.algorithm.keySchedule(key, true);

		// zero initial vector
		this.cbcMode.init(this.algorithm, {
			iv: Buffer.alloc(this.blockSize, 0x00),
			blockSize: this.blockSize,
			isEncryption: true
		});
	}

	process(input)
	{
		if (input.length != this.blockSize) {
			this.state = jCastle.mcrypt.padding.create('zeros').pad(input, this.blockSize);
		} else {
			this.state = input.slice(0);
		}
		this.mac = this.cbcMode.process(this.state);
	}

	finish()
	{
		this.reset();

		return Buffer.slice(this.mac);
	}

	reset(no_reset)
	{
		this.cbcMode = null;
		this.blockSize = 0;
		this.state = null;

		if (no_reset && typeof this.algorithm.reset === 'function') {
			this.algorithm.reset();
		}
		this.algorithm = null;
	}
}

// The GMAC is an invocation of the GCM mode where no data is encrypted.
// All input data to the Mac is processed as additional authenticated data
// with the underlying GCM block cipher.
// galois-mac
jCastle.mac.mode['gmac'] = class
{
    constructor()
    {
        this.gcmMode = null;
        this.blockSize = 0;
        this.algorithm = null;
    }

	init(algorithm, options)
	{
		if (!algorithm) {
			throw jCastle.exception('ALGORITHM_NOT_SET', 'MAC006');
		}

		this.algorithm = algorithm;
		this.blockSize = 'blockSize' in options ? options.blockSize : jCastle._algorithmInfo[this.algorithm.algoName].block_size;
		this.macSize = 'macSize' in options ? options.macSize: this.blockSize;
/*
		var nonce = options.nonce;

		if (nonce == null) {
			throw jCastle.exception('INVALID_NONCE', 'MAC007');
		}
*/
		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		this.algorithm.keySchedule(key, true);

		this.gcmMode = jCastle.mcrypt.mode.create('gcm');
		var gcm_options = {
			nonce: options.nonce,
			key: options.key,
			blockSize: this.blockSize,
			isEncryption: true
		};
		if ('additionalData' in options) gcm_options.additionalData = options.additionalData;
		if ('tagSize' in options) gcm_options.tagSize = options.tagSize;
		
		this.gcmMode.init(this.algorithm, gcm_options);

		this.gcmMode.S0 = Buffer.alloc(this.blockSize);

		// all data will be treated as additional data.
		this.gcmMode.additionalData = Buffer.alloc(0);
	}

	process(input)
	{
		this.gcmMode.additionalData = Buffer.concat([this.gcmMode.additionalData, input]);
		this.gcmMode.S0 = this.gcmMode.galoisHash(this.gcmMode.galoisH, this.gcmMode.S0, input);
	}

	finish()
	{
		var tag = this.gcmMode.finish();

		this.gcmMode = null;
		this.blockSize = 0;
		this.algorithm = null;

		return Buffer.slice(tag, 0, this.macSize);
	}
}

jCastle.mac.mode['gost28147-mac'] = class
{
    constructor()
    {
        this.blockSize = 8;
        this.algorithm = null;
        this.mac = null;
        this.state = null;
    }

	init(algorithm, options)
	{
		this.algorithm = algorithm;
		this.blockSize = options.blockSize;
		this.macSize = 4;
		this.mac = Buffer.alloc(this.blockSize);

		if (!this.algorithm) {
			this.algorithm = jCastle.mcrypt.getAlgorithm('gost');
		} else {
			if (this.algorithm.algoName != 'gost') {
				throw jCastle.exception('GOST28147_REQUIRED', 'MAC008');
			}
		}

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		this.algorithm.keySchedule(key, true);

		this.algorithm.setSbox('Gost28147_CryptoProParamSetA');
	}

	process(input)
	{
		if (input.length != this.blockSize) {
			this.state = jCastle.mcrypt.padding.create('zeros').pad(input, this.blockSize);
		} else {
			this.state = input.slice(0);
		}

		// xor
		this.mac = Buffer.xor(this.mac, this.state);
		this.mac = this.algorithm.calculateMac(this.mac);
	}

	finish()
	{
		this.blockSize = 0;
		this.algorithm = null;
		this.state = null;

		return Buffer.slice(this.mac, 0, this.macSize);
	}
}


// DES based CBC block cipher MAC 
// according to ISO9797, algorithm 3(ANSI X9.19 Retail MAC)
jCastle.mac.mode['iso9797alg3-mac'] = 
jCastle.mac.mode['tripledes-mac'] = 
jCastle.mac.mode['des-ede-mac'] = class
{
    constructor()
    {
        this.blockSize = 8;
        this.algorithm = null;
        this.mac = null;
        this.macSize = 8;
    }

	init(algorithm, options)
	{
		this.algorithm = algorithm;

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		var key = Buffer.from(key);

		if (!key || !key.length) {
			throw jCastle.exception('KEY_NOT_SET', 'MAC009');
		}

		if (!this.algorithm) {
			this.algorithm = jCastle.mcrypt.getAlgorithm('des3');
		} else {
			var des3_list = ['des3', '3des', 'des-ede3', 'tripledes'];
			if (!des3_list.includes(this.algorithm.algoName, )) {
				throw jCastle.exception('DES_REQUIRED', 'MAC010');
			}
		}

		// key check
		if (key.length == 16) {
			this.key1 = key.slice(0, 8);
			this.key2 = key.slice(8);
			this.key3 = this.key1.slice(0);
		} else if (key.length == 24) {
			this.key1 = key.slice(0, 8);
			this.key2 = key.slice(8, 16);
			this.key3 = key.slice(16);
		} else {
			throw jCastle.exception('INVALID_KEYSIZE', 'MAC011');
		}
		
		this.algorithm.keySchedule(this.key1, true);
		
		this.mac = Buffer.alloc(this.blockSize);

		this.cbcMode = jCastle.mcrypt.mode.create('cbc');
		this.cbcMode.init(this.algorithm, {
			iv: options.iv ? options.iv : Buffer.alloc(this.blockSize, 0x00),
			blockSize: this.blockSize,
			isEncryption: true
		});
	}

	process(input)
	{
		if (input.length != this.blockSize) {
			this.state = jCastle.mcrypt.padding.create('zeros').pad(input, this.blockSize);
		} else {
			this.state = input.slice(0);
		}

		this.mac = this.cbcMode.process(this.state);
	}

	finish()
	{
		var des = new jCastle.algorithm[jCastle._algorithmInfo[this.algorithm.algoName].object_name](this.algorithm.algoName);
		
		des.keySchedule(this.key2, true);
		this.mac = des.decryptBlock(this.mac);

		des.keySchedule(this.key3, true);
		this.mac = des.encryptBlock(this.mac);

		this.cbcMode = null;
		this.blockSize = 0;
		this.algorithm = null;

		return Buffer.slice(this.mac, 0, this.macSize);
	}
}

jCastle.mac.mode['vmpc-mac'] = class
{
    constructor()
    {
        this.blockSize = 1;
        this.macSize = 20;
        this.key = null;
        this.iv = null;
        this.rounds = 25;
    }

	init(algorithm, options)
	{
		if (!options.key) {
			throw jCastle.exception('KEY_NOT_SET', 'MAC013');
		}

		this.key = options.key;
		if (!Buffer.isBuffer(this.key))
			this.key = Buffer.from(this.key, 'latin1');

		this.iv = options.iv;
		if (!Buffer.isBuffer(this.iv))
			this.iv = Buffer.from(this.iv, 'latin1');

		if (!this.iv || !this.iv.length || this.iv.length > 768) {
			throw jCastle.exception('INVALID_IV', 'MAC014');
		}

		this.P = new Uint8Array(256);
		this.n = 0;
		this.s = 0;
		this.x1 = this.x2 = this.x3 = this.x4 = this.g = 0;
		this.T = new Uint8Array(32);

		this.expandKey();
	}

	process(input)
	{
		for (var i = 0; i < input.length; i++) {
			this.s = this.P[(this.s + this.P[this.n]) & 0xff];
			var c = (input[i] ^ this.P[(this.P[this.P[this.s]] + 1) & 0xff]) & 0xff;

			this.x4 = this.P[(this.x4 + this.x3) & 0xff];
			this.x3 = this.P[(this.x3 + this.x2) & 0xff];
			this.x2 = this.P[(this.x2 + this.x1) & 0xff];
			this.x1 = this.P[(this.x1 + this.s + c) & 0xff];
			this.T[this.g & 0x1f] = (this.T[this.g & 0x1f] ^ this.x1) & 0xff;
			this.T[(this.g + 1) & 0x1f] = (this.T[(this.g + 1) & 0x1f] ^ this.x2) & 0xff;
			this.T[(this.g + 2) & 0x1f] = (this.T[(this.g + 2) & 0x1f] ^ this.x3) & 0xff;
			this.T[(this.g + 3) & 0x1f] = (this.T[(this.g + 3) & 0x1f] ^ this.x4) & 0xff;
			this.g = (this.g + 4) & 0x1f;

			this.swap(this.n, this.s);
			this.n = (this.n + 1) & 0xff;
		}
	}

	finish()
	{
		// Execute the Post-Processing Phase
		for (var r = 1; r < this.rounds; r++) {
			this.s = this.P[(this.s + this.P[this.n]) & 0xff];

			this.x4 = this.P[(this.x4 + this.x3 + r) & 0xff];
			this.x3 = this.P[(this.x3 + this.x2 + r) & 0xff];
			this.x2 = this.P[(this.x2 + this.x1 + r) & 0xff];
			this.x1 = this.P[(this.x1 + this.s + r) & 0xff];
			this.T[this.g & 0x1f] = (this.T[this.g & 0x1f] ^ this.x1) & 0xff;
			this.T[(this.g + 1) & 0x1f] = (this.T[(this.g + 1) & 0x1f] ^ this.x2) & 0xff;
			this.T[(this.g + 2) & 0x1f] = (this.T[(this.g + 2) & 0x1f] ^ this.x3) & 0xff;
			this.T[(this.g + 3) & 0x1f] = (this.T[(this.g + 3) & 0x1f] ^ this.x4) & 0xff;
			this.g = (this.g + 4) & 0x1f;

			this.swap(this.n, this.s);
			this.n = (this.n + 1) & 0xff;
		}

		// Input T to the IV-phase of the VMPC KSA
		for (var m = 0; m < 768; m++) {
			this.s = this.P[(this.s + this.P[m & 0xff] + this.T[m & 0x1f]) & 0xff];
			this.swap(m & 0xff, this.s);
		}

		// Store 20 new outputs of the VMPC Stream Cipher in table M
		var M = Buffer.alloc(this.macSize);

		for (var i = 0; i < M.length; i++) {
			this.s = this.P[(this.s + this.P[i]) & 0xff];
			M[i] = this.P[(this.P[this.P[this.s]] + 1) & 0xff];

			this.swap(i, this.s);
		}

		return M;
	}

	expandKey()
	{
		for (var i = 0; i < 256; i++) {
			this.P[i] = i;
		}

		for (var m = 0; m < 768; m++) {
			this.s = this.P[(this.s + this.P[m & 0xff] + this.key[m % this.key.length]) & 0xff];
			this.swap(m & 0xff, this.s);
		}

		for (var m = 0; m < 768; m++) {
			this.s = this.P[(this.s + this.P[m & 0xff] + this.iv[m % this.iv.length]) & 0xff];
			this.swap(m & 0xff, this.s);
		}
	}

	swap(x, y)
	{
		var t;
		t = this.P[x]; this.P[x] = this.P[y]; this.P[y] = t;
	}
}

jCastle.mac.mode['cfb-mac'] = class
{
    constructor()
    {
        this.algorithm = null;
        this.key = null;
        this.iv = null;
        this.ncfbMode = null;
        this.blockSize = 0;
        this.mac = null;
        this.state = null;
    }

	init(algorithm, options)
	{
		if (!algorithm) {
			throw jCastle.exception('ALGORITHM_NOT_SET', 'MAC015');
		}

		this.algorithm = algorithm;
		this.blockSize = 'blockSize' in options ? options.blockSize : jCastle._algorithmInfo[this.algorithm.algoName].block_size;

		this.iv = 'iv' in options ? options.iv : Buffer.alloc(0);
		if (!Buffer.isBuffer(this.iv))
			this.iv = Buffer.from(this.iv, 'latin1');

		if (this.iv.length < this.blockSize) {
			this.iv = Buffer.concat([Buffer.alloc(this.blockSize - this.iv.length, 0x00), this.iv]);
		}

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		this.algorithm.keySchedule(key, true);
		this.macSize = 'macSize' in options ? options.macSize : parseInt(this.blockSize / 2);

		// it is ncfb which is the same with java bouncycastle's cfb 

		this.ncfbMode = jCastle.mcrypt.mode.create('ncfb');
		this.ncfbMode.init(this.algorithm, {
			iv: this.iv,
			blocSize: this.blockSize,
			isEncryption: true
		});		
	}

	process(input)
	{
		if (input.length != this.blockSize) {
			this.state = jCastle.mcrypt.padding.create('zeros').pad(input, this.blockSize);
		} else {
			this.state = input.slice(0);
		}

		this.mac = this.ncfbMode.process(this.state);
	}

	finish()
	{
		this.ncfbMode.finish();

		this.algorithm = null;
		this.ncfbMode = null;
		this.blockSize = null;

		return this.macSize ? Buffer.slice(this.mac, 0, this.macSize) : Buffer.slice(this.mac);
	}
}

// https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01
jCastle.mac.mode['poly1305-mac'] = class
{
    constructor()
    {
        this.algorithm = null;
        this.key = null;
        this.iv = null;
        this.macSize = 16;
        this.blockSize = 16;
        this.mac = null;
    }

/*
https://tools.ietf.org/html/rfc7539

2.5.  The Poly1305 Algorithm

   Poly1305 is a one-time authenticator designed by D. J. Bernstein.
   Poly1305 takes a 32-byte one-time key and a message and produces a
   16-byte tag.  This tag is used to authenticate the message.

   The original article ([Poly1305]) is titled "The Poly1305-AES
   message-authentication code", and the MAC function there requires a
   128-bit AES key, a 128-bit "additional key", and a 128-bit (non-
   secret) nonce.  AES is used there for encrypting the nonce, so as to
   get a unique (and secret) 128-bit string, but as the paper states,
   "There is nothing special about AES here.  One can replace AES with
   an arbitrary keyed function from an arbitrary set of nonces to
   16-byte strings."

   Regardless of how the key is generated, the key is partitioned into
   two parts, called "r" and "s".  The pair (r,s) should be unique, and
   MUST be unpredictable for each invocation (that is why it was
   originally obtained by encrypting a nonce), while "r" MAY be
   constant, but needs to be modified as follows before being used: ("r"
   is treated as a 16-octet little-endian number):

   o  r[3], r[7], r[11], and r[15] are required to have their top four
      bits clear (be smaller than 16)

   o  r[4], r[8], and r[12] are required to have their bottom two bits
      clear (be divisible by 4)

   The following sample code clamps "r" to be appropriate:
   (Adapted from poly1305aes_test_clamp.c version 20050207)

   #include "poly1305aes_test.h"

   void poly1305aes_test_clamp(unsigned char r[16])
   {
     r[3] &= 15;
     r[7] &= 15;
     r[11] &= 15;
     r[15] &= 15;
     r[4] &= 252;
     r[8] &= 252;
     r[12] &= 252;
   }

   The "s" should be unpredictable, but it is perfectly acceptable to
   generate both "r" and "s" uniquely each time.  Because each of them
   is 128 bits, pseudorandomly generating them (see Section 2.6) is also
   acceptable.

   The inputs to Poly1305 are:

   o  A 256-bit one-time key

   o  An arbitrary length message

   The output is a 128-bit tag.

   First, the "r" value should be clamped.

   Next, set the constant prime "P" be 2^130-5:
   3fffffffffffffffffffffffffffffffb.  Also set a variable "accumulator"
   to zero.

   Next, divide the message into 16-byte blocks.  The last one might be
   shorter:

   o  Read the block as a little-endian number.

   o  Add one bit beyond the number of octets.  For a 16-byte block,
      this is equivalent to adding 2^128 to the number.  For the shorter
      block, it can be 2^120, 2^112, or any power of two that is evenly
      divisible by 8, all the way down to 2^8.

   o  If the block is not 17 bytes long (the last block), pad it with
      zeros.  This is meaningless if you are treating the blocks as
      numbers.

   o  Add this number to the accumulator.

   o  Multiply by "r".

   o  Set the accumulator to the result modulo p.  To summarize: Acc =
      ((Acc+block)*r) % p.

   Finally, the value of the secret key "s" is added to the accumulator,
   and the 128 least significant bits are serialized in little-endian
   order to form the tag.

2.5.1.  The Poly1305 Algorithms in Pseudocode

      clamp(r): r &= 0x0ffffffc0ffffffc0ffffffc0fffffff
      poly1305_mac(msg, key):
         r = (le_bytes_to_num(key[0..15])
         clamp(r)
         s = le_num(key[16..31])
         accumulator = 0
         p = (1<<130)-5
         for i=1 upto ceil(msg length in bytes / 16)
            n = le_bytes_to_num(msg[((i-1)*16)..(i*16)] | [0x01])
            a += n
            a = (r * a) % p
            end
         a += s
         return num_to_16_le_bytes(a)
         end
*/
	init(algorithm, options)
	{
		if (options.key.length != 32) {
			throw jCastle.exception('INVALID_KEYSIZE', 'MAC016');
		}
		
		this.macSize = 'macSize' in options ? options.macSize : 16;

		/*
		In Ploy1305, the first 16-byte block of the key will be used for r,
		the second part will be used for pad.

		However when with AES working, the second part will be for r.
		the 16-byte block for pad is the result block of AES encryting of the first part,
		with give 32-byte key. AES will encrypt 16-byte block of nonce.
		*/

		/*
		Mostly this code comes from https://github.com/devi/chacha20poly1305

		Originally blocks are 32-bit integers and 64-bit integers,
		here 16-bit integer will be used.
		*/

		if (algorithm) {
			this.algorithm = algorithm;
		}

		this.r = new Array(10);
		this.pad = new Array(8);
		this.h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // important! should be initialized.

		var t = new Array(8);

		var key = options.key;
		if (!Buffer.isBuffer(key))
			key = Buffer.from(key, 'latin1');

		if (this.algorithm) {
			// http://cr.yp.to/mac/poly1305-20050329.pdf
			// http://www.tcs.hut.fi/Studies/T-79.515/slides/S7.Vaarala.pdf

			var nonce = options.nonce;
			if (!Buffer.isBuffer(nonce))
				nonce = Buffer.from(nonce, 'latin1');

			if (!nonce || nonce.length != 16) {
				throw jCastle.exception('INVALID_NONCE', 'MAC017');
			}

			// initialize algorithm with first part of the key
			this.algorithm.keySchedule(key.slice(0, 16), true);

			var key1 = this.algorithm.encryptBlock(nonce);

			for (var i = 0; i < 8; i++) {
				this.pad[i] = key1.readUInt16LE(2 * i);
			}

			// r comes from the second part of the key.
			for (var i = 0; i < t.length; i++) {
				t[i] = key.readUInt16LE(16 + i * 2);
			}
		} else {
			// The Poly1305 Algorithms in Pseudocode

			// r comes from the first part of the key
			for (var i = 0; i < t.length; i++) {
				t[i] = key.readUInt16LE(i * 2);
			}
			// and the second part is used for pad.
			for (var i = 0; i < 8; i++) {
				this.pad[i] = key.readUInt16LE(16 + 2 * i);
			}
		}

		this.r[0] =   t[0]						 & 0x1fff;
		this.r[1] = ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
		this.r[2] = ((t[1] >>> 10) | (t[2] <<  6)) & 0x1f03;
		this.r[3] = ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
		this.r[4] = ((t[3] >>>  4) | (t[4] << 12)) & 0x00ff;
		this.r[5] =  (t[4] >>>  1)				 & 0x1ffe;
		this.r[6] = ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
		this.r[7] = ((t[5] >>> 11) | (t[6] <<  5)) & 0x1f81;
		this.r[8] = ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
		this.r[9] =  (t[7] >>>  5)				 & 0x007f;
	}

	process(input)
	{
		var is_final = false;
		var d = [];
		
		this.state = Buffer.slice(input);

		if (this.state.length < this.blockSize) {
			is_final = true;
			var pos = this.state.length;
			this.state = Buffer.concat([this.state, Buffer.alloc(this.blockSize - pos)]);
			this.state[pos] = 0x01;
		}

		var hi_bit = is_final ? 0 : (1 << 11);

		var t = new Array(8);

		for (var i = 0; i < t.length; i++) {
			t[i] = this.state.readUInt16LE(i * 2);
		}

		this.h[0] +=   t[0]	                        & 0x1fff;
		this.h[1] += ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
		this.h[2] += ((t[1] >>> 10) | (t[2] <<  6)) & 0x1fff;
		this.h[3] += ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
		this.h[4] += ((t[3] >>>  4) | (t[4] << 12)) & 0x1fff;
		this.h[5] +=  (t[4] >>>  1)			        & 0x1fff;
		this.h[6] += ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
		this.h[7] += ((t[5] >>> 11) | (t[6] <<  5)) & 0x1fff;
		this.h[8] += ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
		this.h[9] += (t[7] >>>  5)  | hi_bit;

		// multiply
		for (var i = 0, c = 0; i < 10; i++) {
			d[i] = c;
			for (var j = 0; j < 10; j++) {
				d[i] += (this.h[j] & 0xffff) * ((j <= i) ? this.r[i - j] : (5 * this.r[ i + 10 - j]));
				if (j == 4) {
					c = d[i] >>> 13;
					d[i] &= 0x1fff;
				}
			}
			c += d[i] >>> 13;
			d[i] &= 0x1fff;
		}
		c = (c << 2) + c;
		c += d[0];
		d[0] = c & 0x1fff;
		c >>>= 13;
		d[1] += c;
 
		this.h = d.slice(0);
	}

	finish()
	{
		var g = new Array(10);

		var c = this.h[1] >>> 13;
		this.h[1] &= 0x1fff;
		for (var i = 2; i < 10; i++) {
			this.h[i] += c;
			c = this.h[i] >>> 13;
			this.h[i] &= 0x1fff;
		}
		this.h[0] += (c * 5);
		c = this.h[0] >>> 13;
		this.h[0] &= 0x1fff;
		this.h[1] += c;
		c = this.h[1] >>> 13;
		this.h[1] &= 0x1fff;
		this.h[2] += c;

		g[0] = this.h[0] + 5;
		c = g[0] >>> 13;
		g[0] &= 0x1fff;
		for (var i = 1; i < 10; i++) {
			g[i] = this.h[i] + c;
			c = g[i] >>> 13;
			g[i] &= 0x1fff;
		}
		g[9] = (g[9] - (1 << 13)) & 0xffff;

		var b = (g[9] >>> 15) - 1;
		var nb = ~b;

		for (var i = 0; i < 10; i++) {
			this.h[i] = (this.h[i] & nb) | (g[i] & b) & 0xffff;
		}

		this.h[0] = (this.h[0]	    ) | (this.h[1] << 13);
		this.h[1] = (this.h[1] >>>  3) | (this.h[2] << 10);
		this.h[2] = (this.h[2] >>>  6) | (this.h[3] <<  7);
		this.h[3] = (this.h[3] >>>  9) | (this.h[4] <<  4);
		this.h[4] = (this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14);
		this.h[5] = (this.h[6] >>>  2) | (this.h[7] << 11);
		this.h[6] = (this.h[7] >>>  5) | (this.h[8] <<  8);
		this.h[7] = (this.h[8] >>>  8) | (this.h[9] <<  5);

		var f = (this.h[0] & 0xffff) + this.pad[0];
		this.h[0] = f;
		for (var i = 1; i < 8; i++) {
			f = (this.h[i] & 0xffff) + this.pad[i] + (f >>> 16);
			this.h[i] = f;
		}

		this.mac = Buffer.alloc(16);

		for (var i = 0; i < 8; i++) {
			this.mac.writeUInt16LE(this.h[i] & 0xffff, i * 2);
		}

		this.h = null;
		this.r = null;

		return this.macSize ? Buffer.slice(this.mac, 0, this.macSize) : Buffer.slice(this.mac);
	}
}

jCastle.mac.Mode = jCastle.mac.mode;

module.exports = jCastle.mac.mode;