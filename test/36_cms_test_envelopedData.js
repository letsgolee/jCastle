const jCastle = require('../lib/index');
const QUnit = require('qunit');

QUnit.module("CMS");
QUnit.test("KeyAgreement Test (DH)", function(assert) {

    var testVectors = [
/*
RFC 2631			Diffie-Hellman Key Agreement Method

2.1.  Key Agreement

   The first stage of the key agreement process is to compute a shared
   secret number, called ZZ.  When the same originator and recipient
   public/private key pairs are used, the same ZZ value will result.
   The ZZ value is then converted into a shared symmetric cryptographic
   key. When the originator employs a static private/public key pair,
   the introduction of a public random value ensures that the resulting
   symmetric key will be different for each key agreement.

2.1.1.  Generation of ZZ

   X9.42 defines that the shared secret ZZ is generated as follows:

     ZZ = g ^ (xb * xa) mod p

   Note that the individual parties actually perform the computations:

     ZZ = (yb ^ xa)  mod p  = (ya ^ xb)  mod p

   where ^ denotes exponentiation

         ya is party a's public key; ya = g ^ xa mod p
         yb is party b's public key; yb = g ^ xb mod p
         xa is party a's private key
         xb is party b's private key
         p is a large prime
         q is a large prime
         g = h^{(p-1)/q} mod p, where
         h is any integer with 1 < h < p-1 such that h{(p-1)/q} mod p > 1
           (g has order q mod p; i.e. g^q mod p = 1 if g!=1)
         j a large integer such that p=qj + 1
         (See Section 2.2 for criteria for keys and parameters)

   In [CMS], the recipient's key is identified by the CMS
   RecipientIdentifier, which points to the recipient's certificate.
   The sender's public key is identified using the
   OriginatorIdentifierOrKey field, either by reference to the sender's
   certificate or by inline inclusion of a public key.

2.1.2.  Generation of Keying Material

   X9.42 provides an algorithm for generating an essentially arbitrary
   amount of keying material from ZZ. Our algorithm is derived from that
   algorithm by mandating some optional fields and omitting others.

     KM = H ( ZZ || OtherInfo)

   H is the message digest function SHA-1 [FIPS-180] ZZ is the shared
   secret value computed in Section 2.1.1. Leading zeros MUST be
   preserved, so that ZZ occupies as many octets as p. For instance, if
   p is 1024 bits, ZZ should be 128 bytes long.  OtherInfo is the DER
   encoding of the following structure:

     OtherInfo ::= SEQUENCE {
       keyInfo KeySpecificInfo,
       partyAInfo [0] OCTET STRING OPTIONAL,
       suppPubInfo [2] OCTET STRING
     }

     KeySpecificInfo ::= SEQUENCE {
       algorithm OBJECT IDENTIFIER,
       counter OCTET STRING SIZE (4..4) }

   Note that these ASN.1 definitions use EXPLICIT tagging. (In ASN.1,
   EXPLICIT tagging is implicit unless IMPLICIT is explicitly
   specified.)

   algorithm is the ASN.1 algorithm OID of the CEK wrapping algorithm
     with which this KEK will be used. Note that this is NOT an
     AlgorithmIdentifier, but simply the OBJECT IDENTIFIER. No
     parameters are used.

   counter is a 32 bit number, represented in network byte order. Its
     initial value is 1 for any ZZ, i.e. the byte sequence 00 00 00 01
     (hex), and it is incremented by one every time the above key
     generation function is run for a given KEK.

   partyAInfo is a random string provided by the sender. In CMS, it is
     provided as a parameter in the UserKeyingMaterial field (encoded as
     an OCTET STRING). If provided, partyAInfo MUST contain 512 bits.

   suppPubInfo is the length of the generated KEK, in bits, represented
     as a 32 bit number in network byte order. E.g. for 3DES it would be
     the byte sequence 00 00 00 C0.

   To generate a KEK, one generates one or more KM blocks (incrementing
   counter appropriately) until enough material has been generated.  The
   KM blocks are concatenated left to right I.e. KM(counter=1) ||
   KM(counter=2)...

   Note that the only source of secret entropy in this computation is
   ZZ.  Even if a string longer than ZZ is generated, the effective key
   space of the KEK is limited by the size of ZZ, in addition to any
   security level considerations imposed by the parameters p and q.
   However, if partyAInfo is different for each message, a different KEK
   will be generated for each message. Note that partyAInfo MUST be used
   in Static-Static mode, but MAY appear in Ephemeral-Static mode.

2.1.3.  KEK Computation

   Each key encryption algorithm requires a specific size key (n). The
   KEK is generated by mapping the left n-most bytes of KM onto the key.
   For 3DES, which requires 192 bits of keying material, the algorithm
   must be run twice, once with a counter value of 1 (to generate K1',
   K2', and the first 32 bits of K3') and once with a counter value of 2
   (to generate the last 32 bits of K3). K1',K2' and K3' are then parity
   adjusted to generate the 3 DES keys K1,K2 and K3.  For RC2-128, which
   requires 128 bits of keying material, the algorithm is run once, with
   a counter value of 1, and the left-most 128 bits are directly
   converted to an RC2 key. Similarly, for RC2-40, which requires 40
   bits of keying material, the algorithm is run once, with a counter
   value of 1, and the leftmost 40 bits are used as the key.

2.1.4.  Keylengths for common algorithms

   Some common key encryption algorithms have KEKs of the following
   lengths.

     3-key 3DES      192 bits
     RC2-128        128 bits
     RC2-40         40 bits

   RC2 effective key lengths are equal to RC2 real key lengths.

2.1.5.  Public Key Validation

   The following algorithm MAY be used to validate a received public key
   y.

     1. Verify that y lies within the interval [2,p-1]. If it does not,
        the key is invalid.
     2. Compute y^q mod p. If the result == 1, the key is valid.
        Otherwise the key is invalid.

   The primary purpose of public key validation is to prevent a small
   subgroup attack [LAW98] on the sender's key pair. If Ephemeral-Static
   mode is used, this check may not be necessary. See also [P1363] for
   more information on Public Key validation.

   Note that this procedure may be subject to pending patents.

2.1.6.  Example 1

   ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09
                      0a 0b 0c 0d 0e 0f 10 11 12 13

   The key wrap algorithm is 3DES-EDE wrap.

   No partyAInfo is used.

   Consequently, the input to the first invocation of SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ

   30 1d
      30 13
         06 0b 2a 86 48 86 f7 0d 01 09 10 03 06          ; 3DES wrap OID
         04 04
            00 00 00 01                                        ; Counter
      a2 06
         04 04
         00 00 00 c0                                        ; key length

   And the output is the 20 bytes:

   a0 96 61 39 23 76 f7 04 4d 90 52 a3 97 88 32 46 b6 7f 5f 1e

   The input to the second invocation of SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ
   30 1d
      30 13
         06 0b 2a 86 48 86 f7 0d 01 09 10 03 06          ; 3DES wrap OID
         04 04
            00 00 00 02                                        ; Counter
      a2 06
         04 04
         00 00 00 c0                                        ; key length

   And the output is the 20 bytes:

   f6 3e b5 fb 5f 56 d9 b6 a8 34 03 91 c2 d3 45 34 93 2e 11 30

   Consequently,
   K1'=a0 96 61 39 23 76 f7 04
   K2'=4d 90 52 a3 97 88 32 46
   K3'=b6 7f 5f 1e f6 3e b5 fb

   Note: These keys are not parity adjusted
*/        
        {
            zz: '00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13',
            partyAInfo: null,
            expected: `
                a0 96 61 39 23 76 f7 04
                4d 90 52 a3 97 88 32 46
                b6 7f 5f 1e f6 3e b5 fb`,
            wrapAlgo: '3des',
            keylen: 24
        },
/*
RFC 2631			Diffie-Hellman Key Agreement Method

2.1.7.  Example 2

   ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09
                      0a 0b 0c 0d 0e 0f 10 11 12 13

   The key wrap algorithm is RC2-128 key wrap, so we need 128 bits (16
   bytes) of keying material.

   The partyAInfo used is the 64 bytes

   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01

   Consequently, the input to SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ
   30 61
      30 13
         06 0b 2a 86 48 86 f7 0d 01 09 10 03 07           ; RC2 wrap OID
         04 04
            00 00 00 01                                        ; Counter
      a0 42
         04 40
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01 ; partyAInfo
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
      a2 06
         04 04
            00 00 00 80                                     ; key length

   And the output is the 20 bytes:

   48 95 0c 46 e0 53 00 75 40 3c ce 72 88 96 04 e0 3e 7b 5d e9

   Consequently,
   K=48 95 0c 46 e0 53 00 75 40 3c ce 72 88 96 04 e0
*/
        {
            zz: '00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13',
            partyAInfo: `
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01`,
            expected: '48 95 0c 46 e0 53 00 75 40 3c ce 72 88 96 04 e0',
            wrapAlgo: 'rc2-128',
            keylen: 16
        },
//
/*
RFC 3565       Use of the AES Encryption Algorithm in CMS

2.3.  KeyAgreeRecipientInfo Fields

   This section describes the conventions for using ES-DH or SS-DH and
   AES with the CMS enveloped-data content type to support key
   agreement.  When key agreement is used, then the RecipientInfo
   keyAgreeRecipientInfo CHOICE MUST be used.

   The KeyAgreeRecipient version MUST be 3.

   The EnvelopedData originatorInfo field MUST be the originatorKey
   alternative.  The originatorKey algorithm fields MUST contain the
   dh-public-number object identifier with absent parameters.  The
   originatorKey publicKey MUST contain the originator's ephemeral
   public key.

   The EnvelopedData ukm MAY be present.

   The EnvelopedData keyEncrytionAlgorithm MUST be the id-alg-ESDH
   algorithm identifier [CMSALG].

2.3.1.  ES-DH/AES Key Derivation

   Generation of the AES KEK to be used with the AES-key wrap algorithm
   is done using the method described in [DH].

2.3.1.1.  Example 1

   ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09
                      0a 0b 0c 0d 0e 0f 10 11 12 13

   The key wrap algorithm is AES-128 wrap, so we need 128 bits (16
   bytes) of keying material.

   No partyAInfo is used.

   Consequently, the input to SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ
   30 1b
      30 11
         06 09 60 86 48 01 65 03 04 01 05           ; AES-128 wrap OID
         04 04
            00 00 00 01                             ; Counter
      a2 06
         04 04
         00 00 00 80                                ; key length

   And the output is the 32 bytes:

   d6 d6 b0 94 c1 02 7a 7d e6 e3 11 72 94 a3 53 64 49 08 50 f9

   Consequently,

   K= d6 d6 b0 94 c1 02 7a 7d e6 e3 11 72 94 a3 53 64
*/
        {
            zz: '00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13',
            partyAInfo: null,
            expected: "d6 d6 b0 94 c1 02 7a 7d e6 e3 11 72 94 a3 53 64",
            wrapAlgo: 'aes-128',
            keylen: 16
        },
/*
RFC 3565       Use of the AES Encryption Algorithm in CMS

2.3.1.2.  Example 2

   ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09
                      0a 0b 0c 0d 0e 0f 10 11 12 13

   The key wrap algorithm is AES-256 key wrap, so we need 256 bits (32
   bytes) of keying material.

   The partyAInfo used is the 64 bytes

   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01

   Consequently, the input to first invocation of SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ
   30 5f
      30 11
         06 09 60 86 48 01 65 03 04 01 2d            ; AES-256 wrap OID
         04 04
            00 00 00 01                              ; Counter
      a0 42
         04 40
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01 ; partyAInfo
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
      a2 06
         04 04
            00 00 01 00                              ; key length

   And the output is the 20 bytes:

   88 90 58 5C 4E 28 1A 5C 11 67 CA A5 30 BE D5 9B 32 30 D8 93

   The input to second invocation of SHA-1 is:

   00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ
   30 5f
      30 11
         06 09 60 86 48 01 65 03 04 01 2d            ; AES-256 wrap OID
         04 04
            00 00 00 02                              ; Counter
      a0 42
         04 40
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01 ; partyAInfo

            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
            01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
      a2 06
         04 04
            00 00 01 00                              ; key length

   And the output is the 20 bytes:

   CB A8 F9 22 BD 1B 56 A0 71 C9 6F 90 36 C6 04 2C AA 20 94 37

   Consequently,

   K = 88 90 58 5C 4E 28 1A 5C 11 67 CA A5 30 BE D5 9B
       32 30 D8 93 CB A8 F9 22 BD 1B 56 A0 71 C9 6F 90
*/       
        {
            zz: '00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13',
            partyAInfo: ` 
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01
                01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01`,
            expected: `
                88 90 58 5C 4E 28 1A 5C 11 67 CA A5 30 BE D5 9B
                32 30 D8 93 CB A8 F9 22 BD 1B 56 A0 71 C9 6F 90`,
            wrapAlgo: 'aes-256',
            keylen: 32
        }
    ];

    for (var i = 0; i < testVectors.length; i++) {
        var vector = testVectors[i];

        var zz = Buffer.from(vector.zz.replace(/[^0-9A-F]/ig, ''), 'hex');
        var expected = Buffer.from(vector.expected.replace(/[^0-9A-F]/ig, ''), 'hex');
        var partyAInfo = null;
        if ('partyAInfo' in vector && vector.partyAInfo)
            partyAInfo = Buffer.from(vector.partyAInfo.replace(/[^0-9A-F]/ig, ''), 'hex');

        var wrap_algo = vector.wrapAlgo;
        var keylen = 'keylen' in vector ? vector.keylen : jCastle.mcrypt.getKeySize(wrap_algo);
    	var counter = 1;

        // key length in bits 
        var keylen_bl = Buffer.alloc(4);
        keylen_bl.writeInt32BE(keylen * 8, 0);
        // console.log('keylen_bl: ', keylen_bl);

        var derived_key = Buffer.alloc(keylen);

        // hash algorithm
        var hash_algo = 'sha-1';
        var md = jCastle.digest.create(hash_algo);
        var pos = 0;


        // des3's key length is 24 and sha-1's length is 20. so the routine need to work once more.

        while (pos < keylen) {

            // counter block
            var cnt_bl = Buffer.alloc(4);
            cnt_bl.writeInt32BE(counter, 0);
            // console.log('cnt_bl: ', cnt_bl);

            // input data for hash algorithm
            var schema = {
                type: jCastle.asn1.tagSequence,
                items: [{ // keyInfo
                    type: jCastle.asn1.tagSequence,
                    items: [{
                        type: jCastle.asn1.tagOID,
                        value: jCastle.keyWrap.getOID(wrap_algo)
                    }, {
                        type: jCastle.asn1.tagOctetString,
                        value: cnt_bl
                    }]
                }]
            };

            // PartyAInfo
            if (partyAInfo && partyAInfo.length) {
                schema.items.push({
                    tagClass: jCastle.asn1.tagClassContextSpecific,
                    type: 0x00,
                    constructed: true,
                    items: [{
                        type: jCastle.asn1.tagOctetString,
                        value: partyAInfo
                    }]
                });
            }

            // suppPubInfo
            schema.items.push({ 
                tagClass: jCastle.asn1.tagClassContextSpecific,
                type: 0x02,
                constructed: true,
                items: [{
                    type: jCastle.asn1.tagOctetString,
                    value: keylen_bl
                }]
            });

            var input = jCastle.asn1.create().getDER(schema);

            input = Buffer.from(input, 'latin1');

            var output = md.start().update(zz).update(input).finalize();
            
            if (output.length + pos < keylen)
                derived_key.set(output, pos);
            else 
                derived_key.set(output.slice(0, keylen - pos), pos);

            counter++;
            pos += output.length;
        }

        // console.log('derived_key: ', derived_key);
        // console.log('expected:    ', expected);

        assert.ok(derived_key.equals(expected), 'Test Example ' + (i+1));
        // console.log('Test Example ' + (i+1) + ': ', derived_key.equals(expected));
    }

});
// console.log('--------------------------------------------------------------');


/*
RFC 5753              Use of ECC Algorithms in CMS

7.2.  Other Syntax

   The following additional syntax is used here.

   When using ECDSA with SignedData, ECDSA signatures are encoded using
   the type:

      ECDSA-Sig-Value ::= SEQUENCE {
        r INTEGER,
        s INTEGER }

   ECDSA-Sig-Value is specified in [PKI-ALG].  Within CMS, ECDSA-Sig-
   Value is DER-encoded and placed within a signature field of
   SignedData.

   When using ECDH and ECMQV with EnvelopedData, AuthenticatedData, and
   AuthEnvelopedData, ephemeral and static public keys are encoded using
   the type ECPoint.  Implementations MUST support uncompressed keys,
   MAY support compressed keys, and MUST NOT support hybrid keys.

      ECPoint ::= OCTET STRING

   When using ECMQV with EnvelopedData, AuthenticatedData, and
   AuthEnvelopedData, the sending agent's ephemeral public key and
   additional keying material are encoded using the type:

      MQVuserKeyingMaterial ::= SEQUENCE {
        ephemeralPublicKey      OriginatorPublicKey,
        addedukm            [0] EXPLICIT UserKeyingMaterial OPTIONAL  }

   The ECPoint syntax is used to represent the ephemeral public key and
   is placed in the ephemeralPublicKey publicKey field.  The additional
   user keying material is placed in the addedukm field.  Then the
   MQVuserKeyingMaterial value is DER-encoded and placed within the ukm
   field of EnvelopedData, AuthenticatedData, or AuthEnvelopedData.

   When using ECDH or ECMQV with EnvelopedData, AuthenticatedData, or
   AuthEnvelopedData, the key-encryption keys are derived by using the
   type:

      ECC-CMS-SharedInfo ::= SEQUENCE {
        keyInfo         AlgorithmIdentifier,
        entityUInfo [0] EXPLICIT OCTET STRING OPTIONAL,
        suppPubInfo [2] EXPLICIT OCTET STRING  }

   The fields of ECC-CMS-SharedInfo are as follows:

      keyInfo contains the object identifier of the key-encryption
      algorithm (used to wrap the CEK) and associated parameters.  In
      this specification, 3DES wrap has NULL parameters while the AES
      wraps have absent parameters.

      entityUInfo optionally contains additional keying material
      supplied by the sending agent.  When used with ECDH and CMS, the
      entityUInfo field contains the octet string ukm.  When used with
      ECMQV and CMS, the entityUInfo contains the octet string addedukm
      (encoded in MQVuserKeyingMaterial).

      suppPubInfo contains the length of the generated KEK, in bits,
      represented as a 32-bit number, as in [CMS-DH] and [CMS-AES].
      (For example, for AES-256 it would be 00 00 01 00.)

   Within CMS, ECC-CMS-SharedInfo is DER-encoded and used as input to
   the key derivation function, as specified in Section 3.6.1 of [SEC1].

   NOTE: ECC-CMS-SharedInfo differs from the OtherInfo specified in
   [CMS-DH].  Here, a counter value is not included in the keyInfo field
   because the key derivation function specified in Section 3.6.1 of
   [SEC1] ensures that sufficient keying data is provided.
*/
QUnit.test("EnvelpedData KeyAgreement Test 1", function(assert) {

    var ec_privkey_pem =`
    MIIBXwIBADCB6gYHKoZIzj0CATCB3gIBATArBgcqhkjOPQEBAiB/////////////
    ////////////////////////////7TBEBCAqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
    qqqqqqqYSRShRAQge0Je0Je0Je0Je0Je0Je0Je0Je0Je0Je0JgtenHcQyGQEQQQq
    qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq0kWiCuGaG4oIa04B7dLHdI0UyS
    PU1+bXxhsinpxaJ+ztPZAiAQAAAAAAAAAAAAAAAAAAAAFN753qL3nNZYEmMaXPXT
    7QIBCARtMGsCAQEEIAHuUF+hqgHX+87jRXu2vIYVP9Ia7ikwXO/pJN0TpNIYoUQD
    QgAEDQmu8fQdG6MwV6tHDvEKHfo3D6oVEaKoic9QI3hS/bAnxyPWlFauSvtgVdAm
    MGoTcTVb67F0tf/NgFrCuIYWDQ==`;


    var cms_pem = `
    -----BEGIN CMS-----
    MIAGCSqGSIb3DQEHA6CAMIACAQAxggFdoYIBWQIBA6BToVEwCwYHKoZIzj0CAQUAA0IABDHq1J8I
    gGyH8uyuNxzk3lhUaCG4k7Kq4u1uBiTXiUeJKtzwdP0VsPz3JSHOY1btkN9Agz3wK5Y9aqRIMG84
    Kw8wFQYGK4EEAQ4CMAsGCWCGSAFlAwQBLTCB5zCB5DCBtzCBrjEmMCQGCSqGSIb3DQEJARYXcm9z
    ZXR0YW5ldEBtZW5kZWxzb24uZGUxCzAJBgNVBAYTAkRFMQ8wDQYDVQQIDAZCZXJsaW4xDzANBgNV
    BAcMBkJlcmxpbjEiMCAGA1UECgwZbWVuZGVsc29uLWUtY29tbWVyY2UgR21iSDEiMCAGA1UECwwZ
    bWVuZGVsc29uLWUtY29tbWVyY2UgR21iSDENMAsGA1UEAwwEbWVuZAIEQ4798wQoU6Gfe6jpUQBc
    dUOrm0ZLLSyED0NyZuJ5btK69H+C73Pdf9TMYPQ6ajCABgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEu
    MBEEDOqcvcuXhbYQv/7tQQIBEKCABFf/d8u1ID5dmKsrgVeMXo+al/6F8TaBxKN9WTqr8J0FXGiq
    nC/s1Z0TOzgF1xxnYmu7rs2faVjW8OykBMTWXjCVNuQ7nS16SVC51IA1UU7xWJF79QTSyuMAAAAA
    AAAAAAAA
    -----END CMS-----`;

	var pki = jCastle.pki.create('ecdsa');
	pki.parsePrivateKey(ec_privkey_pem);

	var cms = jCastle.cms.create();
	var cms_info = cms.parse(cms_pem, {
		cmsKey: {
            privateKey: ec_privkey_pem
        }
	});

    // console.log('cms_info: ', cms_info);

	// var pptable = prettyPrint(cms_info);
	// document.getElementById('printarea').appendChild(pptable);

	var content = "Content-Type: text/plain\r\nContent-Transfer-Encoding: 7bit\r\n\r\nHalo Dunia";
	assert.equal(cms_info.content.encryptedContentInfo.content.toString(), content, "EnvelopedData - kari Test");
    // console.log("EnvelopedData - kari Test: ", cms_info.content.encryptedContentInfo.content.toString() == content);

});

// console.log('--------------------------------------------------------------');

// CMS EnvelopedData - KeyTransRecipientInfo
QUnit.test("CMS Parsing Test", function(assert) {

 
    // cms-example-enveloped-data
    // https://pkijs.org/examples/CMSEnvelopedExample.html
    // plaintext: hello world
    
    var plaintext = "hello world";
    
    var cert_pem = `
    -----BEGIN CERTIFICATE-----
    MIIC1jCCAcCgAwIBAgIBATALBgkqhkiG9w0BAQUwHjEcMAkGA1UEBhMCUlUwDwYD
    VQQDHggAVABlAHMAdDAeFw0xNjAxMzExNTAwMDBaFw0xOTAxMzExNTAwMDBaMB4x
    HDAJBgNVBAYTAlJVMA8GA1UEAx4IAFQAZQBzAHQwggEiMA0GCSqGSIb3DQEBAQUA
    A4IBDwAwggEKAoIBAQDOBZhK/11578kywgY+TFIFPlceyA4vZgQmHY/k+lzxW/z3
    bCJtZCydaskMnkUvGMJXk20tWLCitOflEdZGJndMFQhJzPQic+uYI/6eevHN5T/e
    BFbS41tGdHtC8ZBbNuzZdvK8Aheo7n8pa3jO1wnqLrA72eurZZZjiQgH7JdczfAV
    4CV6GZFgCqtmWJv3ZFTYb8DoxqcLay996DGovaOytuIcE1D6lTdNAJyK9OsPK5K3
    JK/YeHKJoE54XwhKqY0WA0NyN7M8TkH6rA9oXEaYmG9O13OkT/MV4j1lCdqzC5HK
    loeARpQwfHFfLEqyUsG6szgnT9RFGQCe+e/kLowPAgMBAAGjIzAhMBIGA1UdEwEB
    /wQIMAYBAf8CAQMwCwYDVR0PBAQDAgAGMAsGCSqGSIb3DQEBBQOCAQEAJhpp6MTF
    ieLqbq5BQvB4RoecUwR2mxMyzKmaXcU3hVX42VDii9QCec5opMRy2urLLJa7lj7h
    yZhjeG98tKuNiUA7n+rBVTH4dIuo9iZCd8IoGuh+3WNLJAjfAxuRuRi636nBYu7X
    gRX9fOFzkQMY+X6nkv5BLLm8Mjq3OqfhkqHdqHUPojfEt+tJIE1VTYTLm4ltyV74
    1l7C404a+ni71hE8FLN1v6fE60hYvVN99Z32g+LjhI/XKo/nXJoY/GPhDLYRYQiE
    UIpq71ELRLJ0FkP4MdlVNerV4z9G9XESwGYkjjkDJ+MvXnqR9dhTOfQIEcW3M8FA
    rF8ExnmdLo8P+Q==
    -----END CERTIFICATE-----`;
    
    var cert = new jCastle.certificate();
    var cert_info = cert.parse(cert_pem);
    
    var privkey_pem = `
    -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOBZhK/11578ky
    wgY+TFIFPlceyA4vZgQmHY/k+lzxW/z3bCJtZCydaskMnkUvGMJXk20tWLCitOfl
    EdZGJndMFQhJzPQic+uYI/6eevHN5T/eBFbS41tGdHtC8ZBbNuzZdvK8Aheo7n8p
    a3jO1wnqLrA72eurZZZjiQgH7JdczfAV4CV6GZFgCqtmWJv3ZFTYb8DoxqcLay99
    6DGovaOytuIcE1D6lTdNAJyK9OsPK5K3JK/YeHKJoE54XwhKqY0WA0NyN7M8TkH6
    rA9oXEaYmG9O13OkT/MV4j1lCdqzC5HKloeARpQwfHFfLEqyUsG6szgnT9RFGQCe
    +e/kLowPAgMBAAECggEAUd/9VwjHYFdAEVD0ZDu2eOj+fHgq0wFq8q7a6bfpye2x
    ya6KvAiMhn7SqZYYjo/7ZAxt3hCaGf9lDS8ahcRxsqXFJncyKqMA5PShEuBvSlEq
    IZR94M+EDarq9X7EzMs2M3JHIxp9xqAJny9b0m+5O/0UAqUnOHVl3+asb2HCAZoK
    rhcStW7plMKCX0GB7wiuFmtH2fgDHGDOU/qtZsUdx/uv7JeD53cEskIUKydH9OBm
    I8WbKc5xOyk45BaX4kjGAXMKntc1PvjZhYX1HP8jwIfqggBD1TFCfRiDi1xCPO95
    mm9RP/Qx9w+BfQX+1Sjw8O6ZQB7qLXSK0nU2JFICSQKBgQD+NToGqENyAiHWl+tA
    m/AjAqBF8vjbqsBsxWT/eFEd/g13raR0LDcF3Ubhtgqa9SdanyT2VpC4UyeELEGP
    9cgAJDVtV+52Aznhy3bMdx3dqVHwpm930x7C9CGrUOYIwLFs3kanFbOb9jg0S5Fj
    TayciIkI7NgilXGRqPkd98r1UwKBgQDPeWfxdomIoV2yz0YO3xHkaPqE+8L9zp3b
    nDliofIGrseDdCEwEai0zNlYkUbLUXWMiMLnDTetYTvl7w7QqE3p/CnbJ/DBoStU
    7SbJZ8znyvW/e1oEoSBxOgzChJZVY9APJIGJW1+2IknlD62y2FSVA3YS0KpAlB2T
    tkzaNEIa1QKBgQCCJJ3gaqSc6ZqJUp2OJkd6pQ2IwivFylVZWnWqlN5yjG44px1a
    nIhO6EoxpBEp4/iR3If/1bGhrHC+qimmmh4adG8l266pnF01zAS2CQWxRc49dff7
    UIqfJH1YR8J9GKm9Is7pG6MoZZXAsC9ut4V3Xi9J8nd0vS23dNqVDRdLIQKBgBbu
    yHp8K7+adozpNEk4hvXEVMyWN3tudyxrHDy2wdXTQ+JX18NEcG1rpyqPBFA89M1P
    4JtBbsIPWVuVDQIrWFFgug+rXoVIl02P2RWyD4gfewJrVAvm83sQe5CUrzlJCxph
    YqAYJYAwUhKrpPt7xf2ioE58GhWBSbOmFuCXnibxAoGAUkVYcVwtNd3YbWolIjh2
    h1cLyIOkKdvqcRxAl1z/I+wCe7klSSwJCEqcif/Ueh+CqcywsC3Itwg/znhHITaM
    ZbuGLJrFuuc9t5hofd5Ht9tkWTQEpI3SNVsou/SbP1Xb+PL6ndPNsSVUPoXvIRdM
    wOwbyIdR5BgbRsDIgBbYTLo=
    -----END PRIVATE KEY-----`;
    
    var pki = new jCastle.pki();
    pki.parse(privkey_pem);
    
    var cms_pem = `
    -----BEGIN CMS-----
    MIIBnQYJKoZIhvcNAQcDoIIBjjCCAYoCAQIxggE/MIIBOwIBADAjMB4xHDAJBgNV
    BAYTAlJVMA8GA1UEAx4IAFQAZQBzAHQCAQEwDQYJKoZIhvcNAQEHMAAEggEANC4W
    md1QBE149JdVNg3CAOqj5zrYqm3A3DH3bYsrVwIGJdGyRCuhkDZYCpqBtN5b7dqc
    ASfYKMxelfj83d1bXo/Z86YKLP1sqdtgQtssqJ6K/oh8wKUszkf+vdjmgva5dkHo
    WIHTZKIM1JbKgmg4VkF1gypfjhhyeS4LJEbYJ7nvWAj/3vERUpVnjx2m+VRjCZQp
    KOsQC86MRcP9MatgSts0jQIyt4Bskq5vVf7mL3AHnQjyRUfPG8ME92QVpXc1CyRf
    +LtSo9Fo4oOgSkfvmI/cNlD5Ub/QoMQvlaP93heAznvFX2zgdsLdmDg3VowWpk8v
    3GhY+ob5/7cAVjHesjCABgkqhkiG9w0BBwEwHQYJYIZIAWUDBAECBBBQaVvcG+Dp
    DpFv5eBsn+b6oIAEEBBnz/LR+52k+iVq/gMONRMAAAAA
    -----END CMS-----`;
    
    var cms = new jCastle.cms();
    var cms_info = cms.parse(cms_pem, {
        cmsKey: {
            privateKey: privkey_pem
        }
    });

    // console.log('cms_info: ', cms_info);
    
    // var pptable = prettyPrint(cms_info);
    // document.getElementById('printarea').appendChild(pptable);
    
    assert.equal(cms_info.content.encryptedContentInfo.content.toString(), plaintext, "encrypted content test");
    // console.log('encrypted content test: ', cms_info.content.encryptedContentInfo.content.toString() == plaintext);
    
    var pubkey_pem = pki.exportPublicKey({ format: 'pem' });
    
    // console.log('pubkey_pem: ', pubkey_pem);
    
    var plaintext2 = 'jCastle Crypto Library';
    
    var cms2 = jCastle.cms.create();
    var cms_pem2 = cms2.exportCMS(cms_info, {
        cmsKey: {
            recipient: {
                publicKey: pubkey_pem
            }
        },
        content: plaintext2, 
        format: 'pem'
    });
    
    // console.log('cms_pem2: ', cms_pem2);
    
    var cms3 = new jCastle.cms();
    var cms_info3 = cms3.parse(cms_pem2, {
        cmsKey: {
            privateKey: privkey_pem
        }
    });
    
    // console.log('cms_info3: ', cms_info3);
    
    // var pptable = prettyPrint(cms_info3);
    // document.getElementById('printarea1').appendChild(pptable);
    
    assert.equal(cms_info3.content.encryptedContentInfo.content.toString(), plaintext2, "encrypted content test");
    // console.log('encrypted content test 2: ', cms_info3.content.encryptedContentInfo.content.toString() == plaintext2);
});
    
QUnit.test("CMS EnvelopedData - KeyTransRecipientInfo export / parse Step Test", function(assert) {
    
    
    var privkey_pem = `
    -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOBZhK/11578ky
    wgY+TFIFPlceyA4vZgQmHY/k+lzxW/z3bCJtZCydaskMnkUvGMJXk20tWLCitOfl
    EdZGJndMFQhJzPQic+uYI/6eevHN5T/eBFbS41tGdHtC8ZBbNuzZdvK8Aheo7n8p
    a3jO1wnqLrA72eurZZZjiQgH7JdczfAV4CV6GZFgCqtmWJv3ZFTYb8DoxqcLay99
    6DGovaOytuIcE1D6lTdNAJyK9OsPK5K3JK/YeHKJoE54XwhKqY0WA0NyN7M8TkH6
    rA9oXEaYmG9O13OkT/MV4j1lCdqzC5HKloeARpQwfHFfLEqyUsG6szgnT9RFGQCe
    +e/kLowPAgMBAAECggEAUd/9VwjHYFdAEVD0ZDu2eOj+fHgq0wFq8q7a6bfpye2x
    ya6KvAiMhn7SqZYYjo/7ZAxt3hCaGf9lDS8ahcRxsqXFJncyKqMA5PShEuBvSlEq
    IZR94M+EDarq9X7EzMs2M3JHIxp9xqAJny9b0m+5O/0UAqUnOHVl3+asb2HCAZoK
    rhcStW7plMKCX0GB7wiuFmtH2fgDHGDOU/qtZsUdx/uv7JeD53cEskIUKydH9OBm
    I8WbKc5xOyk45BaX4kjGAXMKntc1PvjZhYX1HP8jwIfqggBD1TFCfRiDi1xCPO95
    mm9RP/Qx9w+BfQX+1Sjw8O6ZQB7qLXSK0nU2JFICSQKBgQD+NToGqENyAiHWl+tA
    m/AjAqBF8vjbqsBsxWT/eFEd/g13raR0LDcF3Ubhtgqa9SdanyT2VpC4UyeELEGP
    9cgAJDVtV+52Aznhy3bMdx3dqVHwpm930x7C9CGrUOYIwLFs3kanFbOb9jg0S5Fj
    TayciIkI7NgilXGRqPkd98r1UwKBgQDPeWfxdomIoV2yz0YO3xHkaPqE+8L9zp3b
    nDliofIGrseDdCEwEai0zNlYkUbLUXWMiMLnDTetYTvl7w7QqE3p/CnbJ/DBoStU
    7SbJZ8znyvW/e1oEoSBxOgzChJZVY9APJIGJW1+2IknlD62y2FSVA3YS0KpAlB2T
    tkzaNEIa1QKBgQCCJJ3gaqSc6ZqJUp2OJkd6pQ2IwivFylVZWnWqlN5yjG44px1a
    nIhO6EoxpBEp4/iR3If/1bGhrHC+qimmmh4adG8l266pnF01zAS2CQWxRc49dff7
    UIqfJH1YR8J9GKm9Is7pG6MoZZXAsC9ut4V3Xi9J8nd0vS23dNqVDRdLIQKBgBbu
    yHp8K7+adozpNEk4hvXEVMyWN3tudyxrHDy2wdXTQ+JX18NEcG1rpyqPBFA89M1P
    4JtBbsIPWVuVDQIrWFFgug+rXoVIl02P2RWyD4gfewJrVAvm83sQe5CUrzlJCxph
    YqAYJYAwUhKrpPt7xf2ioE58GhWBSbOmFuCXnibxAoGAUkVYcVwtNd3YbWolIjh2
    h1cLyIOkKdvqcRxAl1z/I+wCe7klSSwJCEqcif/Ueh+CqcywsC3Itwg/znhHITaM
    ZbuGLJrFuuc9t5hofd5Ht9tkWTQEpI3SNVsou/SbP1Xb+PL6ndPNsSVUPoXvIRdM
    wOwbyIdR5BgbRsDIgBbYTLo=
    -----END PRIVATE KEY-----`;

    var password = 'password';

    var bits = 1024;
    
    /* root */
    
    var root = new jCastle.pki();
    root.parsePrivateKey(privkey_pem);
    
    var issuer = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Chungcheongbuk-do'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'localityName',
        value: 'Cheongju'
    }, {
        name: 'organizationName',
        value: 'jCastle Corp'
    }, {
        name: 'organizationalUnitName',
        value: 'WebCert Support'
    }, {
        name: 'commonName',
        value: 'jCastle Web CA'
    }, {
        name: 'emailAddress',
        value: 'support@jcastle.net'
    }];
    
    /* alice */
    
    var alice = jCastle.pki.create('RSA');
    alice.generateKeypair({
        bits: bits,
        exponent: 0x10001
    });
    var alice_privkey_pem = alice.exportPrivateKey({ password: password });

    // console.log('alice privkey pem: ', alice_privkey_pem);
    
    var alice_subject = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Seoul'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'organizationName',
        value: 'DACOCHE'
    }, {
        name: 'commonName',
        value: 'Dacoche Web Flatform'
    }];
    
    var alice_cert_info = {
        type: jCastle.certificate.typeCRT,
        tbs: {
            serial: 750365,
            issuer: issuer,
            subject: alice_subject,
            subjectPublicKeyInfo: alice.getPublicKeyInfo(),
            extensions: {
                keyUsage: {
                    list: ['keyEncipherment', 'digitalSignature'],
                    critical: true
                }
            }
        },
        algo: {
            signHash: 'SHA-256',
            signAlgo: 'RSASSA-PKCS1-V1_5' // 'RSASSA-PSS', 'EC', 'DSA'
        }
    };
    
    var alice_cert = jCastle.certificate.create();
    var alice_cert_pem = alice_cert.setSignKey(root).exportCertificate(alice_cert_info);

    // console.log('alice cert pem: ', alice_cert_pem);
    
    /* bob */
    
    var bob = jCastle.pki.create('RSA');
    bob.generateKeypair({
        bits: bits,
        exponent: 0x10001
    });
    var bob_privkey_pem = bob.exportPrivateKey({password: password});

    // console.log('bob privkey pem: ', bob_privkey_pem);
    
    var bob_subject = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Seoul'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'organizationName',
        value: 'Hareem'
    }, {
        name: 'commonName',
        value: 'Hareem Food'
    }];
    
    var bob_cert_info = {
        type: jCastle.certificate.typeCRT,
        tbs: {
            serial: 6649112,
            issuer: issuer,
            subject: bob_subject,
            subjectPublicKeyInfo: bob.getPublicKeyInfo(),
            extensions: {
                keyUsage: {
                    list: ['keyEncipherment', 'digitalSignature'],
                    critical: true
                }
            }
        },
        algo: {
            signHash: 'SHA-256',
            signAlgo: 'RSASSA-PKCS1-V1_5' // 'RSASSA-PSS', 'EC', 'DSA'
        }
    };
    
    var bob_cert = jCastle.certificate.create();
    var bob_cert_pem = bob_cert.setSignKey(root).exportCertificate(bob_cert_info);

    // console.log('bob cert pem: ', bob_cert_pem);
    
    /* alice exports cms with envelopedData - ktri */
    // console.log('alice exports cms with envelopedData - ktri');
    
    var cms_info = {
        "contentType": "envelopedData",
        "content": {
            "recipientInfos": [{
                "type": "keyTransRecipientInfo",
                //"identifierType": "subjectKeyIdentifier", // 만일 recipientIdentifier를 issuer & serialNumber가 아닌 
                                                            // subjectKeyIdentifier로 하고자 할 때
                                                            // 기본 값은 'issuerAndSerialNumber'
                "keyEncryptionAlgorithm": {
                    "algo": "RSA",
                    "padding": {
                        "mode": "RSAES-OAEP", // PKCS1_OAEP
                        "hashAlgo": "sha-1",
                        "mgf": "mgf1",
                        "label": ""
                    }
                }
            }],
            "encryptedContentInfo": {
                "contentEncryptionAlgorithm": {
                    "algo": "aes-128-CBC"
                },
            }
        }
    };
    
    var plaintext = "Hello world!";
    
    var cms = jCastle.cms.create();
    var options = {
        cmsKey: {
            privateKey: alice_privkey_pem,
            password: password,
            certificate: alice_cert_pem,
            recipient: {
                certificate: bob_cert_pem
            }
        },
        content: plaintext
    };
    var cms_pem = cms.exportCMS(cms_info, options);
    
    // console.log('cms_pem: ', cms_pem);
    
    var options = {
        cmsKey: {
            privateKey: bob_privkey_pem,
            password: password
        }
    };
    
    var cms_info = cms.parse(cms_pem, options);

    // console.log('cms_info: ', cms_info);
    
    assert.equal(cms_info.content.encryptedContentInfo.content.toString(), plaintext, "EnvelopedData-ktri Step Test");
    // console.log('EnvelopedData-ktri Step Test: ', cms_info.content.encryptedContentInfo.content.toString() == plaintext);
     
    // var pptable = prettyPrint(cms_info);
    // document.getElementById('printarea2').appendChild(pptable);
    
     
});

// console.log('--------------------------------------------------------------');

// CMS EnvelopedData - PasswordRecipientinfo
QUnit.test("CMS Parsing Test", function(assert) {

 
    // password based cms example
    // https://pkijs.org/examples/CMSEnvelopedPreDefineDataExample.html
    // password: password
    // plaintext: hello world
    // aes-cbc 128
    
    var cms_pem = `
    -----BEGIN CMS-----
    MIHtBgkqhkiG9w0BBwOggd8wgdwCAQIxgZKjgY8CAQCgYQYJKoZIhvcNAQUMMFQE
    QNwYPo2QkGIoljsJY765zgL/X9DV8Vt84FkndCGrNteJIqt3wmdqdXbOsu+TUgy5
    Fr/mYbND5vWnspJuYkzdV30CAggAMAwGCCqGSIb3DQILBQAwDQYJYIZIAWUDBAEt
    BQAEGKgbc5C/25urkAsAhTcNPJreqhE0hR+lcjCABgkqhkiG9w0BBwEwHQYJYIZI
    AWUDBAECBBBIsUH2oxzBLKY/AuyrnJhJoIAEEKXwYlW4M2qrp3drmZBTznQAAAAA
    -----END CMS-----`;
    
    var password = "password";
    var plaintext = "hello world";
    var algo_expected = "aes-128";
    var mode_expected = "cbc";
    
    var cms = new jCastle.cms();
    var cms_info = cms.parse(cms_pem, {
        cmsKey: {
            password: password
        }
    });

    // console.log('cms_info: ', cms_info);
    
    assert.equal(cms_info.content.encryptedContentInfo.content.toString(), plaintext, 'CMS EnvelopedData - PasswordRecipientinfo test 1');
    // console.log('PasswordRecipientinfo test 1: ', cms_info.content.encryptedContentInfo.content.toString() == plaintext);
    
    
    // var pptable = prettyPrint(cms_info);
    // document.getElementById('printarea').appendChild(pptable);
    
    var cms_info = {
        contentType: "envelopedData",
        content: {
            version: 2,
            recipientInfos: [{
                type: "passwordRecipientInfo",
                keyDerivationAlgorithm: {
                    prfHash: 'sha-512'
                },
                keyEncryptionAlgorithm: "aes-256"
            }],
            encryptedContentInfo: {
                contentEncryptionAlgorithm: {
                    algo: "aes-128-CBC"
                }
            }
        }
    };
    
    var cms_data = cms.exportCMS(cms_info, {
        format: 'pem',
        cmsKey: {
            password: password
        },
        content: plaintext
    });
    
    // console.log('cms_data: ', cms_data);
    
    var cms_info2 = cms.parse(cms_data, {
        cmsKey: {
            password: password
        }
    });
    
    assert.equal(cms_info2.content.encryptedContentInfo.content.toString(), plaintext, 'CMS EnvelopedData - PasswordRecipientinfo test 1');
    // console.log('PasswordRecipientinfo test 1: ', cms_info2.content.encryptedContentInfo.content.toString() == plaintext);
    
    // var pptable2 = prettyPrint(cms_info2);
    // document.getElementById('printarea1').appendChild(pptable2);
    
});

// console.log('--------------------------------------------------------------');

// CMS EnvelopedData - KeyAgreeRecipientInfo
QUnit.test("CMS EvelopedData - kari Test", function(assert) {

    var pem = {};

    pem.parameters = `
    -----BEGIN EC PARAMETERS-----
    BggqhkjOPQMBBw==
    -----END EC PARAMETERS-----`;

    pem.ec_privkey = `
    -----BEGIN EC PRIVATE KEY-----
    MHcCAQEEIIUyJBhYBZWIfauIOLSqndTOjdWQ7coqx6dG+z+FBjzroAoGCCqGSM49
    AwEHoUQDQgAEBnoeGGfJ+nzd6eDlLM4dj8SKarOOnETTFH9odBbrMEo6OKpkU4dG
    6OZ0CpBYyzC7EdwdRkofUGSpbB0ynjCElQ==
    -----END EC PRIVATE KEY-----`;
    
    pem.cert = `
    -----BEGIN CERTIFICATE-----
    MIIDQzCCAumgAwIBAgIJAOoxzNZyQlShMAkGByqGSM49BAEwgaAxCzAJBgNVBAYT
    AktSMRcwFQYDVQQIEw5DaHVuZ2NoZW9uZ2J1azETMBEGA1UEBxQKTG9jYWxfbmFt
    ZTEVMBMGA1UEChQMb3JpZ19leGFtcGxlMRIwEAYDVQQLFAlvcmlnX3VuaXQxFDAS
    BgNVBAMTC2pjYXN0bGUubmV0MSIwIAYJKoZIhvcNAQkBFhNsZXRzZ29sZWVAbmF2
    ZXIuY29tMB4XDTIwMDEwMzEyNDUxMFoXDTIwMDIwMjEyNDUxMFowgaAxCzAJBgNV
    BAYTAktSMRcwFQYDVQQIEw5DaHVuZ2NoZW9uZ2J1azETMBEGA1UEBxQKTG9jYWxf
    bmFtZTEVMBMGA1UEChQMb3JpZ19leGFtcGxlMRIwEAYDVQQLFAlvcmlnX3VuaXQx
    FDASBgNVBAMTC2pjYXN0bGUubmV0MSIwIAYJKoZIhvcNAQkBFhNsZXRzZ29sZWVA
    bmF2ZXIuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEBnoeGGfJ+nzd6eDl
    LM4dj8SKarOOnETTFH9odBbrMEo6OKpkU4dG6OZ0CpBYyzC7EdwdRkofUGSpbB0y
    njCElaOCAQkwggEFMB0GA1UdDgQWBBRKuWNDSq8VqD0s2YV2YI88/LCHtzCB1QYD
    VR0jBIHNMIHKgBRKuWNDSq8VqD0s2YV2YI88/LCHt6GBpqSBozCBoDELMAkGA1UE
    BhMCS1IxFzAVBgNVBAgTDkNodW5nY2hlb25nYnVrMRMwEQYDVQQHFApMb2NhbF9u
    YW1lMRUwEwYDVQQKFAxvcmlnX2V4YW1wbGUxEjAQBgNVBAsUCW9yaWdfdW5pdDEU
    MBIGA1UEAxMLamNhc3RsZS5uZXQxIjAgBgkqhkiG9w0BCQEWE2xldHNnb2xlZUBu
    YXZlci5jb22CCQDqMczWckJUoTAMBgNVHRMEBTADAQH/MAkGByqGSM49BAEDSQAw
    RgIhAPDNmL3hSJcR503jLf5Cxorz80uxqB+W3qpy4UhhUyXzAiEAgqauj28bX1k2
    hSGfMhMjNj245zlI7T47mZQjIehUoRY=
    -----END CERTIFICATE-----`;
    
    pem.cms = `
    -----BEGIN CMS-----
    MIIBqAYJKoZIhvcNAQcDoIIBmTCCAZUCAQIxggFZoYIBVQIBA6BRoU8wCQYHKoZI
    zj0CAQNCAAQu5b3KWeFm3XQ44ENItEqcad7CgpezI+lcCakgdX9z6r1ckKyQf91c
    prCp53M7SSD6Xqalmq+LZy7eDKIszZ1jMBwGCSuBBRCGSD8AAjAPBgsqhkiG9w0B
    CRADBgUAMIHeMIHbMIGuMIGgMQswCQYDVQQGEwJLUjEXMBUGA1UECBMOQ2h1bmdj
    aGVvbmdidWsxEzARBgNVBAcUCkxvY2FsX25hbWUxFTATBgNVBAoUDG9yaWdfZXhh
    bXBsZTESMBAGA1UECxQJb3JpZ191bml0MRQwEgYDVQQDEwtqY2FzdGxlLm5ldDEi
    MCAGCSqGSIb3DQEJARYTbGV0c2dvbGVlQG5hdmVyLmNvbQIJAOoxzNZyQlShBCjy
    rljdZlbJMOp1LHc9b7d+rINd1rY7wRNqZ3TgHMq59wO9L/mQmRTgMDMGCSqGSIb3
    DQEHATAUBggqhkiG9w0DBwQIusSaNAbbbGaAEHtFWF9ZDOIS2RFTjnGuwOU=
    -----END CMS-----`;
    
    // here comes the same party's public key for test
    // originally, the other party's public key should be given.
    pem.ec_pubkey = `
    -----BEGIN PUBLIC KEY-----
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEBnoeGGfJ+nzd6eDlLM4dj8SKarOO
    nETTFH9odBbrMEo6OKpkU4dG6OZ0CpBYyzC7EdwdRkofUGSpbB0ynjCElQ==
    -----END PUBLIC KEY-----`;
    
    
    pem.text = 'Hello World! \r\n';

    
    var cms = jCastle.cms.create();
    
    var cms_info = cms.parse(pem.cms, {
        cmsKey: {
            privateKey: pem.ec_privkey
        }
    });

    // console.log('cms_info: ', cms_info);
    
    assert.equal(cms_info.content.encryptedContentInfo.content.toString(), pem.text, "EnvelopedData - kari Test");
    // console.log("EnvelopedData - kari Test", cms_info.content.encryptedContentInfo.content.toString() == pem.text);

    // var pptable = prettyPrint(cms_info);
    // document.getElementById('printarea').appendChild(pptable);
});
    
// console.log('--------------------------------------------------------------');
    
QUnit.test("CMS EvelopedData export/parse Test - kari", function(assert) {
    
    /* basic data */
    
    var private_pem = `    
    -----BEGIN RSA PRIVATE KEY-----
    MIIEowIBAAKCAQEAd75gcW+OTGaofS9S3JNJ3dYfsKQZyZG1g0VmFgTh1L+EfwPn
    SH1iUg3ClBFdK1FPvQmPQaaMfny339g4ZeYkknBg7ia6V0hMVkwPhjxwWMY6nv49
    zOpB/yxocugc7S4OfYrVcRiS1v1RBLwuExvDLOmf2jk6NOFywrdvZi4aTNDr4ISc
    HZc3io2kmqPO6SvGhnAC1FEIa+j3Za2i5xMDlOFMsqxg4s0tk43f4d8o9B902T/l
    fwN/onWpqyCgt9bf0mIWWzK8cjGg0vbnzcNfIPF6wEBygl2zqvbESGFqT8G7sJLj
    kmZed7R/D3IZMDg1wd6d/Z2zJ6n5SzRkcTVYUQIDAQABAoIBAA1X6plZbAr5eZcR
    mfM4eoe836UodDMxCIALULftbVjuyo342mIKjtVD8UXctXwpQHB5SzxumcNSlI7e
    IlLAlZy35yVCrYsiZFdNfIFh5McPt+KVxD88b4RG55C+atLHShgVS3mh2mMYsVmM
    urmoY1Ry6DxCGklgQhCOrlw9kPK0QXM+JW+3OGabOzP6BbaNLeGXDCChkJI8D7/l
    5P9t6vgHaUrrYYMNE74nrrsCCn8T0v84spKG6ZyA0i1nydB3MmP5GDzZcEtfjgpM
    TkjJMztSUsJaLHQ1uM5s58ZIVNS/udfcR/6o3PmqYnQQWm9oPdKPdF562fbmTpzF
    iC9bbe0CgYEA1junKEkzfGAmCaCQaB6nNBHAr8C5WdLgmkZRtVRNnUNSP1V3r4V9
    bwiPSVE49+PbWNduIJo8PRxfb5Gm1W+4Zyrh6vnp2/52j9R6gV6+WqXuTavDiCQi
    +NvANubaJwX9wA5Rd5TEjzut8ThdQgAZWKAdOtSf/sy6zkHKBNlPu5MCgYEAjxbF
    GeK9HW2mvpWjTzbxpS7KHaFcrcxvUXNuZ7m4Gag79nZQ5XCSEuj1p0L6MtjejhtH
    heTC6IZ+CIZs0PyTu3Ygo8H5pkTVaZ2wgVEi8/yferx4MKNZk6Ya0UYutlU1bqko
    JyWHUkh+A6Qnk7edrnJev2PE3cNH3z9A5+wuMwsCgYEActD9wYWZ5mrReA9p1aO4
    ERwCnS85J37xiT1uxTQtdL+D8RWpU5TDqSJ5SN4THigsguzSxP5kkowGShFRzMpX
    llNRSVIvmAxFFsjV70gL1SFhGpeX7/sOEzoTRllrScbYPHpwBxrgTbO6gbGnqZvL
    +ce2YrVaGoE3DRwNXZPqO6kCgYCKlkAy0SPfw9szThVNXObw2P+TcT0lbBMJLabq
    ObuwxfvFu1Sg1MX2IMIEzV8tLlVoB83fRfDta43YTfJI+8lOUJxOX0qgGp0k3UEe
    Duquq6f/JVm3qg7RbZkdxj7qBF9rHdUxDS0iqem7NxvJ+5ZyZn2UG1qKe2A6PrZr
    qpoYfwKBgJ2Vxcy/PlEKeM6IFB97mKOSt8vP3c77kJVEDUoTqskgmGatd/EweBkW
    qW4xLcm4+R/Iq9ZQKTNcc3CXIrE/n0ApaT1MatSorWamT49T7R+mJ/rz+AlqvQ+m
    vupbfQ4R+68KsjpnE7JJiHhiVnqz+GE3YJMPLFot32fZB9Oj1Dyr
    -----END RSA PRIVATE KEY-----`;
            
    var brainpoolP512t1_pem = `-----BEGIN EC PARAMETERS-----
    MIIBogIBATBMBgcqhkjOPQEBAkEAqt2duNvpxIs/1OauM8n8B8swjbOzydIO1mOc
    ynAzCHF9TZsAm8ZoQq7NoSrmo4DmKIH/Ly2CxoUoqmBWWDpI8zCBhARAqt2duNvp
    xIs/1OauM8n8B8swjbOzydIO1mOcynAzCHF9TZsAm8ZoQq7NoSrmo4DmKIH/Ly2C
    xoUoqmBWWDpI8ARAfLu8+UQc+rduGJDkaITq4yH3DAvLSYFSeJdQS+w+NqYrzfoj
    BJdlQPZFAIXy2uFFwiVTtGV2NokYDqJXGGdCPgSBgQRkDs5cEniHF7nBugbLwqb+
    uoWEJFjFbd6dsXWNOcAxPYK6UXNc2z6kmap3p9aUOmT3o/Jf4m8GtRuqJpb6kDXa
    W1NL1ZX1rw+iyJI3bISs4btOMBm3FjTAETEVnK4DzunZkyGEvu8ha9cd8trfhqYn
    MG7P+W27i6zhmLYeAPizMgJBAKrdnbjb6cSLP9TmrjPJ/AfLMI2zs8nSDtZjnMpw
    MwhwVT5cQUypJhlBhmEZf6wQRx2x04EIXdrdtYeWgpypAGkCAQE=
    -----END EC PARAMETERS-----`;

    var password = 'password';
    
    /* root */
    
    var root_pki = new jCastle.pki('RSA');
    root_pki.parsePrivateKey(private_pem);
    
    var issuer = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Chungcheongbuk-do'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'localityName',
        value: 'Cheongju'
    }, {
        name: 'organizationName',
        value: 'jCastle Corp'
    }, {
        name: 'organizationalUnitName',
        value: 'WebCert Support'
    }, {
        name: 'commonName',
        value: 'jCastle Web CA'
    }, {
        name: 'emailAddress',
        value: 'support@jcastle.net'
    }];
    
    /* alice */
    
    var alice = new jCastle.pki('ECDSA');
    alice.parseParameters(brainpoolP512t1_pem);
    alice.generateKeypair();

    var alice_pubkey = alice.getPublicKey();

    var alice_privkey_pem = alice.exportPrivateKey({ password: password });

    // console.log('alice privkey pem: ', alice_privkey_pem);

    var alice_subject = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Seoul'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'organizationName',
        value: 'DACOCHE'
    }, {
        name: 'commonName',
        value: 'Dacoche Web Flatform'
    }];
    
    var alice_cert_info = {
        type: jCastle.Certificate.typeCRT,
        tbs: {
            serial: 750365,
            issuer: issuer,
            subject: alice_subject,
            subjectPublicKeyInfo: alice.getPublicKeyInfo(),
            extensions: {
                keyUsage: {
                    list: ['keyAgreement'],
                    critical: true
                }
            }
        },
        algo: {
            signHash: 'SHA-256',
            signAlgo: 'RSASSA-PKCS1-V1_5' // 'RSASSA-PSS', 'EC', 'DSA'
        }
    };
    
    var alice_cert = jCastle.certificate.create();
    alice_cert.setSignKey(root_pki);
    
    var alice_cert_pem = alice_cert.exportCertificate(alice_cert_info);
    
    // console.log('alice cert pem: ', alice_cert_pem);
    
    /* bob */
    
    var bob = new jCastle.pki('ECDSA');
    bob.parseParameters(brainpoolP512t1_pem);
    bob.generateKeypair();

    var bob_pubkey = bob.getPublicKey();

    var bob_privkey_pem = bob.exportPrivateKey();

    // console.log('bob privkey pem: ', bob_privkey_pem);

    var bob_subject = [{
        name: 'countryName',
        value: 'KR',
        type: jCastle.asn1.tagPrintableString
    }, {
        name: 'stateOrProvinceName',
        value: 'Seoul'
        // type: jCastle.asn1.tagUTF8String // default
    }, {
        name: 'organizationName',
        value: 'Hareem'
    }, {
        name: 'commonName',
        value: 'Hareem Food'
    }];
    
    var bob_cert_info = {
        type: jCastle.Certificate.typeCRT,
        tbs: {
            serial: 664976470112,
            issuer: issuer,
            subject: bob_subject,
            subjectPublicKeyInfo: bob.getPublicKeyInfo(),
            extensions: {
                keyUsage: {
                    list: ['keyAgreement'],
                    critical: true
                }
            }
        },
        algo: {
            signHash: 'SHA-256',
            signAlgo: 'RSASSA-PKCS1-V1_5' // 'RSASSA-PSS', 'EC', 'DSA'
        }
    };
    
    var bob_cert = jCastle.certificate.create();
    bob_cert.setSignKey(root_pki);
    
    var bob_cert_pem = bob_cert.exportCertificate(bob_cert_info);
    
    // console.log('bob cert pem: ', bob_cert_pem);
    
    /* alice exports cms file. */
    
    var cms_info = 
    {
        "contentType":"envelopedData",
        "content":{
            "recipientInfos":[{
                // "originatorType": "subjectKeyIdentifier", // 만일 originatorr를 originatorKey가 아닌 subjectKeyIdentifier로 하고자 할 때
                                                             // 만일 issuer & serialNumber로 하고자 한다면 'issuerAndSerialNumber'값으로 줄 것.
                                                             // 만일 인증서가 추가되지 않으면 기본 값으로 originatorKey가 됨.
                // "identifierType": "subjectKeyIdentifier", // 만일 recipientIdentifier를 issuer & serialNumber가 아닌 
                                                             // subjectKeyIdentifier로 하고자 할 때
                                                             // 기본 값은 'issuerAndSerialNumber'
                "type":"keyAgreeRecipientInfo",
                "keyEncryptionAlgorithm":{
                    "algo":"dhSinglePass-stdDH-sha1kdf-scheme",
                    "wrap":"3des"
                }
            }],
            "encryptedContentInfo":{
                "contentType":"data",
                "contentEncryptionAlgorithm":{
                    "algo":"des-EDE3-CBC"
                }
            }
        }
    };
    
    var content = "Hello world!";
    
    //2. input data:
    //	1) originator's certificate or public key
    //	2) originator's private key to encrypt content
    //	3) content to be encrypted
    //	4) recipients' certificates or public key and keyAgreeRecipientIdentifier(issuer and serialNumber etc)
    //	5) originator's ephemeral private key and ephemeral public key for MQVSinglePass-stdDH-*kdf-scheme
    //	6) recipients' ephemeral public key for MQVSinglePass-stdDH-*kdf-scheme

    var options = {
        cmsKey: {
            privateKey: alice_privkey_pem,
            password: password,
            certificate: alice_cert_pem,
            recipient: {
                //ridType: 'subjectKeyIdentifier', // 만일 keyAgreeRecipientIdentifier를 issuer & serialNumber가 아닌 
                                                   // subjectKeyIdentifier로 하고자 할 때
                certificate: bob_cert_pem
            }
        },
        content: content,
        format: 'pem'
    };
    
    var cms = jCastle.cms.create();
    var cms_pem = cms.exportCMS(cms_info, options);

    // console.log('cms_pem: ', cms_pem);
    
    /* bob parse cms file exported by alice */
    
    var options = {
        cmsKey: {
            privateKey: bob_privkey_pem
        }
    };
    var cms_info = cms.parse(cms_pem, options);
    // console.log('cms_info: ', cms_info);
        
    assert.equal(cms_info.content.encryptedContentInfo.content.toString(), "Hello world!", "EnvelopedData - kari Test");
    // console.log("EnvelopedData - kari Test: ", cms_info.content.encryptedContentInfo.content.toString() == "Hello world!");
    

    // keyAgreeRecipientInfo
    var kari_data = `A1 82 
    01 55 02 01 03 A0 51 A1  4F 30 09 06 07 2A 86 48
    CE 3D 02 01 03 42 00 04  2E E5 BD CA 59 E1 66 DD
    74 38 E0 43 48 B4 4A 9C  69 DE C2 82 97 B3 23 E9
    5C 09 A9 20 75 7F 73 EA  BD 5C 90 AC 90 7F DD 5C
    A6 B0 A9 E7 73 3B 49 20  FA 5E A6 A5 9A AF 8B 67
    2E DE 0C A2 2C CD 9D 63  30 1C 06 09 2B 81 05 10
    86 48 3F 00 02 30 0F 06  0B 2A 86 48 86 F7 0D 01
    09 10 03 06 05 00 30 81  DE 30 81 DB 30 81 AE 30
    81 A0 31 0B 30 09 06 03  55 04 06 13 02 4B 52 31
    17 30 15 06 03 55 04 08  13 0E 43 68 75 6E 67 63
    68 65 6F 6E 67 62 75 6B  31 13 30 11 06 03 55 04
    07 14 0A 4C 6F 63 61 6C  5F 6E 61 6D 65 31 15 30
    13 06 03 55 04 0A 14 0C  6F 72 69 67 5F 65 78 61
    6D 70 6C 65 31 12 30 10  06 03 55 04 0B 14 09 6F
    72 69 67 5F 75 6E 69 74  31 14 30 12 06 03 55 04
    03 13 0B 6A 63 61 73 74  6C 65 2E 6E 65 74 31 22
    30 20 06 09 2A 86 48 86  F7 0D 01 09 01 16 13 6C
    65 74 73 67 6F 6C 65 65  40 6E 61 76 65 72 2E 63
    6F 6D 02 09 00 EA 31 CC  D6 72 42 54 A1 04 28 F2
    AE 58 DD 66 56 C9 30 EA  75 2C 77 3D 6F B7 7E AC
    83 5D D6 B6 3B C1 13 6A  67 74 E0 1C CA B9 F7 03
    BD 2F F9 90 99 14 E0`;
    
    kari_data = kari_data.replace(/([^a-f0-9]+)/ig, '');
    
    var asn1 = jCastle.asn1.create();
    
    var kari_asn1 = asn1.parse(Buffer.from(kari_data, 'hex'));
    //console.log(kari_asn1);
    
    var kari_info = jCastle.cms.asn1.keyAgreeRecipientInfo.parse(kari_asn1);
    // console.log('kari_info: ', kari_info);

    assert.ok(kari_info.keyEncryptionAlgorithm.keyAgreement == 'dhSinglePass-stdDH', 'kari parsing test');
});

// console.log('--------------------------------------------------------------');

// CMS EnvelopedData - KEKRecipientInfo
QUnit.test("CMS Parsing Test", function(assert) {

 
    // pre-defined kek based cms example
    // https://pkijs.org/examples/CMSEnvelopedPreDefineDataExample.html
    // kek: 010203040506070809
    // plaintext: hello world
    // aes-cbc 128
    
    var cms_pem = `
    -----BEGIN CMS-----
    MIGcBgkqhkiG9w0BBwOggY4wgYsCAQIxQqJAAgEEMBIEEP/si50s+lXoSYGUdrGB
    jEIwDQYJYIZIAWUDBAEtBQAEGFP+APVz4I27Skk/XxzaUp39i52NeCCh/TCABgkq
    hkiG9w0BBwEwHQYJYIZIAWUDBAECBBBEkx25EyaXh+1FPsGmnm9UoIAEEFuhFu37
    rOZseT5kfV6WSuQAAAAA
    -----END CMS-----`;
    
    var plaintext = "hello world";
    var kek = Buffer.from("010203040506070809");
       
    var cms = new jCastle.cms();
    var encrypted_data_info = cms.parse(cms_pem, {
        cmsKey: {
            wrappingKey: kek
        }
    });
    
    // console.log('encrypted_data_info: ', encrypted_data_info);
    
    // var pptable = prettyPrint(encrypted_data_info);
    // document.getElementById('printarea').appendChild(pptable);
        
    var content = "Hello World!";
    
    var cms_info = {
        contentType: "envelopedData",
        content: {
            recipientInfos: [{
                type: "kekRecipientInfo",
                keyEncryptionAlgorithm: "aes-256"
            }],
            encryptedContentInfo: {
                contentType: "data",
                contentEncryptionAlgorithm: {
                    algo: "aes-128-CBC"
                }//,
    //          content: "hello world"
            }
        }
    };
    
    var prng = new jCastle.prng();
    var kek = prng.nextBytes(16);
    
    var cms = new jCastle.cms();
    cms_data = cms.exportCMS(cms_info, {
        content: content,
        cmsKey: {
            wrappingKey: kek
        },
        format: 'base64'
    });
    // console.log('cms_data: ');
    // console.log(jCastle.util.lineBreak(cms_data));
    
    var cms_info2 = cms.parse(cms_data, {
        cmsKey: {
            wrappingKey: kek
        }
    });
    
    // console.log('cms_info2: ', cms_info2);

    // var pptable2 = prettyPrint(cms_info2);
    // document.getElementById('printarea1').appendChild(pptable2);
    
    assert.equal(cms_info2.content.encryptedContentInfo.content.toString(), content, "CMS EnvelopedData - KEKRecipientInfo Test");
    // console.log("KEKRecipientInfo Test: ", cms_info2.content.encryptedContentInfo.content.toString() == content);
    
});

QUnit.test("CMS EnvelopedData - kekRecipientInfo Test", function(assert) {

 
    // pre-defined kek based cms example
    // https://pkijs.org/examples/CMSEnvelopedPreDefineDataExample.html
    // kek: 010203040506070809
    // plaintext: hello world
    // aes-cbc 128
    //
    // caution! kek is not a hex string!

    var cms_pem = `
    -----BEGIN CMS-----
    MIGcBgkqhkiG9w0BBwOggY4wgYsCAQIxQqJAAgEEMBIEEP/si50s+lXoSYGUdrGB
    jEIwDQYJYIZIAWUDBAEtBQAEGFP+APVz4I27Skk/XxzaUp39i52NeCCh/TCABgkq
    hkiG9w0BBwEwHQYJYIZIAWUDBAECBBBEkx25EyaXh+1FPsGmnm9UoIAEEFuhFu37
    rOZseT5kfV6WSuQAAAAA
    -----END CMS-----`;


	var plaintext = "hello world";
	var kek = Buffer.from("010203040506070809"); // it is not a hex string!

	var cms = new jCastle.cms();
	var encrypted_data_info = cms.parse(cms_pem, {
		cmsKey: {
			wrappingKey: kek
		}
	});

    // console.log('encrypted_data_info: ', encrypted_data_info);
    // console.log(encrypted_data_info.content.recipientInfos);
    // console.log(encrypted_data_info.content.encryptedContentInfo.contentEncryptionAlgorithm);

	// var pptable = prettyPrint(encrypted_data_info);
	// document.getElementById('printarea1').appendChild(pptable);
	
	assert.equal(encrypted_data_info.content.encryptedContentInfo.content.toString(), plaintext, 'kekRecipientInfo test');
    // console.log('kekRecipientInfo test: ', encrypted_data_info.content.encryptedContentInfo.content.toString() == plaintext);
});

QUnit.test("CMS EnvelopedData - kekRecipientInfo Step Test", function(assert) {

	var content = "Hello world!";

	var wrappingKey = Buffer.from('0102030405060708090a0b0c0d0e0f10', 'hex');

	var cms = jCastle.cms.create();

	var cms_info = {
		contentType: 'envelopedData',
		content: {
			recipientInfos: [{
				type: 'kekRecipientInfo',
				keyEncryptionAlgorithm: 'aes-256'
			}],
			encryptedContentInfo: {
				contentEncryptionAlgorithm: {
					algo: 'aes-128-CBC'
				}
			}
		}
	};

	var options = {
		cmsKey: {
			wrappingKey: wrappingKey
		},
		content: content,
		format: 'pem'
	};
	var cms_pem = cms.exportCMS(cms_info, options);

    // console.log('cms_pem: ', cms_pem);

	var options = {
		cmsKey: {
			wrappingKey: wrappingKey
		}
	};
	var cms_info = cms.parse(cms_pem, options);

    // console.log('cms_info: ', cms_info);

	assert.equal(cms_info.content.encryptedContentInfo.content.toString(), content, 'CMS EnvelopedData - kekRecipientInfo Step Test');
    // console.log('kekRecipientInfo Test 2: ', cms_info.content.encryptedContentInfo.content.toString() == content);

});